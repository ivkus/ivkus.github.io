<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 存留处</title>
    <link>https://ivkus.github.io/posts/</link>
    <description>存留处 (Posts)</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 24 Mar 2020 21:54:51 +0800</lastBuildDate>
    
    <atom:link href="https://ivkus.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Systemd阅读笔记</title>
      <link>https://ivkus.github.io/posts/systemd_read/</link>
      <pubDate>Tue, 24 Mar 2020 21:54:51 +0800</pubDate>
      
      <guid>https://ivkus.github.io/posts/systemd_read/</guid>
      <description>&lt;p&gt;Systemd的争议挺大的，不来看看大家为什么抵制它吗？&lt;/p&gt;
&lt;p&gt;需要理顺数据结构，再抓关键流程。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Reading Date:
20201211 Fri
20201212 Sat
20201213 Sun
	集中的3天看，理顺了基本的框架
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;overview&#34;&gt;Overview&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# commit 5916c54a8dabd25efa0d78deef78fbfab684b8a4 

  No             filename  linenum
   1            execute.c     6514
   2               unit.c     6367
   3      load-fragment.c     5851
   4            manager.c     4978
   5            service.c     4587
   6             cgroup.c     3778
   7             socket.c     3517
   8       dbus-execute.c     3459
   9       dbus-manager.c     3317
  10               main.c     2930
  11          dbus-unit.c     2475
  12          namespace.c     2384
  13              mount.c     2204
  14        dbus-cgroup.c     1718
  15                job.c     1698
  16               swap.c     1690
  17               dbus.c     1250
  18        transaction.c     1201
  19          automount.c     1129
  20             device.c     1120
  21              timer.c     956
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;拉取了src/core/下代码最多的几个文件。从这个大致能看出来复杂度集中在哪些方面，作为调度各类进程运行状态的一个程序，execute相关的复杂度最大当之无愧，控制进程执行会涉及到方方面面，这也是systemd不愿意跨系统移植的最大阻力吧。&lt;/p&gt;
&lt;p&gt;unit/service/socket/mount/device/timer/automount/swap这些东西是一类，是作为一种entry而存在，是被动、被调用、被使用的实体。&lt;/p&gt;
&lt;p&gt;manager/job/transaction/load-fratment是内阁，作为进程驱动的存在。&lt;/p&gt;
&lt;p&gt;dbus则是暴露了内部功能给其他进程使用，作为接待处，要负责请求命令的转换，所以归为一块相对独立的功能。&lt;/p&gt;
&lt;h2 id=&#34;data-structure&#34;&gt;Data Structure&lt;/h2&gt;
&lt;h3 id=&#34;manager&#34;&gt;Manager&lt;/h3&gt;
&lt;p&gt;如其名所示，&lt;code&gt;Manager&lt;/code&gt;是整个systemd的核心所在。这是一个巨大的结构体。&lt;/p&gt;
&lt;p&gt;在运行时，主循环就在做一件事，dispatch各种queue。这些个queue都是附着在manager上的，比如&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;load queue&lt;/p&gt;
&lt;p&gt;加载解析unit file到内存中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;run queue&lt;/p&gt;
&lt;p&gt;job存在的地方，处理本职工作的地方&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;gc job&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;gc unit&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;cleanup&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;cgroup realize&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;dbus queue&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;unit&#34;&gt;Unit&lt;/h3&gt;
&lt;p&gt;每个UnitType都有自己的&lt;code&gt;UnitVTable&lt;/code&gt;注册到全局，&lt;code&gt;UnitVTable&lt;/code&gt;用于操作&lt;code&gt;Unit&lt;/code&gt;。这也是Manager用于控制各类unit的手段。Manager不关心具体的每个unit该怎么操作，它只需要关注自己需要那些操作行为，然后定义到vtable里，由各类unit自己去实现。&lt;/p&gt;
&lt;h3 id=&#34;job&#34;&gt;Job&lt;/h3&gt;
&lt;p&gt;需要关注Job状态在何时进行转换。&lt;/p&gt;
&lt;h2 id=&#34;components&#34;&gt;Components&lt;/h2&gt;
&lt;p&gt;Systemd开发组在开发的过程中逐渐抽象出来的组件，对于项目级别来说是很好用的。这些代码都放在&lt;code&gt;src/libsystemd&lt;/code&gt;下面，头文件则在&lt;code&gt;src/systemd&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;sd-event&#34;&gt;sd-event&lt;/h3&gt;
&lt;p&gt;类似于&lt;code&gt;GIO&lt;/code&gt;，封装了自己的eventloop；socketfd、timer、signal都作为一个event source，可以绑定自己的处理函数上去。&lt;/p&gt;
&lt;h3 id=&#34;sd-bus&#34;&gt;sd-bus&lt;/h3&gt;
&lt;p&gt;Systemd自己的DBus实现。&lt;/p&gt;
&lt;h2 id=&#34;startup-procedure-and-main-loop&#34;&gt;Startup Procedure and main loop&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;大量使用了查表，是个查表狂魔项目。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;静心想想一个init程序要干什么，它的运行时表现是什么？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开机的时候要启动各种程序&lt;/li&gt;
&lt;li&gt;其他程序跑出来的zombie进程要收割&lt;/li&gt;
&lt;li&gt;开机后用户也会起进服务（daemon），现在这个工作依托给了systemd来完成。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;systemd其实也是一个server程序，只不过和这个server交互的方式比较不一样，不是通过tcp，虽然它也支持，但主要还是dbus的那个unix socket，外加各种信号。而通过&lt;code&gt;sd-event&lt;/code&gt;的统一，这些交互都化身为&lt;code&gt;sd-event-source&lt;/code&gt;，可以被epoll监听。为什么说systemd是linux only，可能也是得益于linux上才有signalfd/eventfd/timerfd吧。&lt;/p&gt;
&lt;h3 id=&#34;startup&#34;&gt;Startup&lt;/h3&gt;
&lt;p&gt;启动是最复杂的。作为一个要兜底的进程，需要考虑到各种婆婆妈妈的情况。&lt;/p&gt;
&lt;p&gt;在代码里写死的启动项目，叫&lt;code&gt;SPECIAL_DEFAULT_TARGET &amp;quot;default.target&amp;quot;&lt;/code&gt;。之后之所以能带动起到了的各种unit的启动，是因为有systemd的unit加载启动机制。还好项目的代码写的很明了，对于启动需要关注一个函数就行：&lt;code&gt;manager_startup&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;找到default.target在哪里，这里的寻找过程就奠定了使用时该怎么找启动文件，很冗长也很无聊的代码&lt;/li&gt;
&lt;li&gt;systemd也支持旧式的initrc脚本，总要有个识别旧式启动方式的过程，所以接下来就是这个识别并收为己用的过程。systemd把这个过程命名为generator。&lt;/li&gt;
&lt;li&gt;接下来的过程叫做&lt;code&gt;enumerate_perpetual/enumerate&lt;/code&gt;，用于一些mount的对象，可以发现当前系统里存在的设备。&lt;/li&gt;
&lt;li&gt;dbus也要在这个时候做好准备。&lt;/li&gt;
&lt;li&gt;把&lt;code&gt;SPECIAL_DEFAULT_TARGET&lt;/code&gt;加入到load queue中。这个算是比较标志性的一个点了。可以说systemd真正的启动过程就是从这里来的。关键函数是&lt;code&gt;do_queue_default_job&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;进入&lt;code&gt;sd-event&lt;/code&gt;的循环，正式开始上班。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;do_queue_default_job&#34;&gt;&lt;code&gt;do_queue_default_job&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;把default.target加载到内存里，并连带依赖一起加载的工作是在&lt;code&gt;manager_load_startable_unit_or_warn&lt;/code&gt;中进行的。这里比较关键的接口是&lt;code&gt;manager_load_unit&lt;/code&gt;。这里分2步走&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;manager_load_unit_prepare&lt;/code&gt; : 找到这个目的unit，初始化，然后加入到manager的load_queue中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;manager_dispatch_load_queue&lt;/code&gt; : 循环加载就在这个里面实现。里面有一个while，从&lt;code&gt;m-&amp;gt;load_queue&lt;/code&gt;中不断取unit来加载。虽然刚开始只加入了一个default.target，但是加载default.target的时候会不断的把所依赖的unit插入到&lt;code&gt;m-&amp;gt;load_queue&lt;/code&gt;之中。循环往复，直到所有依赖都加载完成。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这时这些unit终于从文件变成了内存的结构，准备工作完成。接下来启动的工作由&lt;code&gt;manager_add_job&lt;/code&gt;完成。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;manager_add_job&lt;/span&gt;(
                Manager &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;m,
                JobType type,
                Unit &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;unit,
                JobMode mode,
                Set &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;affected_jobs,
                sd_bus_error &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;error,
                Job &lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt;ret)

r &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; manager_add_job(m, JOB_START, target, JOB_ISOLATE, NULL, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;error, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;job);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;看签名的话，&lt;code&gt;manager_add_job&lt;/code&gt;会返回一个job给我们，但是job却不是这个函数里分配的。函数里用了一个临时的Transaction来处理依赖，在transaction里有一个&lt;code&gt;anchor_job&lt;/code&gt;，就是我们所请求的起始job。函数最终返回的就是这个&lt;code&gt;anchor_job&lt;/code&gt;。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Waf - a Python based build system</title>
      <link>https://ivkus.github.io/posts/waf/</link>
      <pubDate>Fri, 26 Jul 2019 23:26:57 +0800</pubDate>
      
      <guid>https://ivkus.github.io/posts/waf/</guid>
      <description>&lt;p&gt;看懂这篇文章需要一点使用waf的经验，不过也不费事，看看例子也够了。&lt;/p&gt;
&lt;h1 id=&#34;构建系统简谈&#34;&gt;构建系统简谈&lt;/h1&gt;
&lt;p&gt;软件构建系统不像是个很多人在研究的东西，所以在网络上很少能找到剖析某个构建系统原理、或者阐述构建系统principle的文章。看ns3的过程中接触到了waf，发现其文档&lt;a href=&#34;https://waf.io/book/&#34;&gt;waf book&lt;/a&gt;很好的阐述了构建系统的一些基础知识，个人认为比cmake的文档好一些。因为其核心只有十几个文件，这个构建系统只需要一个10k+的waf文件，所以可以放到版本库里（像对python的评价一样，batteries included），唯一要求就是环境中有python，而这对一个开发人员来说显然不是一件困难的事情。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;|-- Build.py
|-- ConfigSet.py
|-- Configure.py
|-- Context.py
|-- Errors.py
|-- Logs.py
|-- Node.py
|-- Options.py
|-- Runner.py
|-- Scripting.py
|-- Task.py
|-- TaskGen.py
|-- Tools [directory]
|-- Utils.py
|-- ansiterm.py
|-- extras
|-- fixpy2.py
`-- processor.py
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上便是所有waf的内容，可以看到涉及到的文件不算多。Tools下包含了很多语言的构建工具，比如c/c++/java/qt/ruby/tex等等，如果自己有能力定制，可以只保留自己项目里需要的tool，可以做到更小。（虽然个人认为没有必要）&lt;/p&gt;
&lt;h1 id=&#34;核心抽象&#34;&gt;核心抽象&lt;/h1&gt;
&lt;p&gt;如果是写编译语言的(c/c++/rust/go/fc/d)，那么构建系统是每天都在用的。在敲击make&lt;!-- raw HTML omitted --&gt;之后，屏幕上出现了一系列的自动运行的命令，然后就是漫长的等待。用waf也一样，一般是./waf configure build clean dist&amp;hellip;再等机器的轰鸣停止后继续工作流。waf提供了一些核心的抽象，从而能够表达出构建这个活动的几个关键方面：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;像make clean dist类似，可以在构建命令后面自行添加指令，这种capibility由Context提供&lt;/li&gt;
&lt;li&gt;构建系统最重要的功能就是按需构建，要判断出哪些文件要编译而哪些是不用的，这用到了TaskGen与Task的抽象&lt;/li&gt;
&lt;li&gt;并行构建提升速度，由Runner来提供。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这3个抽象几乎相互独立，个人认为是很好的一个抽象。&lt;/p&gt;
&lt;h2 id=&#34;context&#34;&gt;Context&lt;/h2&gt;
&lt;p&gt;每一个跟在./waf后面的指令，都对应一个Context。如果是&lt;code&gt;build/configure/list/step/install/uninstall&lt;/code&gt;，waf自行提供了对应的Context的子类用于执行这些命令，如果是其他的自定义函数，那么就会依托于Context本身，可以在自定义函数里用Context自定义的函数，比如recurse来遍历子目录执行子目录里的同名自定义函数。&lt;/p&gt;
&lt;p&gt;如果项目根目录下的&lt;code&gt;wscript&lt;/code&gt;有do_sth，就可以./waf do_sth&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;do_sth&lt;/span&gt;(ctx):
    ctx&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;load(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;compiler_cxx&amp;#39;&lt;/span&gt;)    &lt;span style=&#34;color:#75715e&#34;&gt;# 加载工具&lt;/span&gt;
    ctx&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;recurse([&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;src&amp;#39;&lt;/span&gt;,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;dep&amp;#39;&lt;/span&gt;])  &lt;span style=&#34;color:#75715e&#34;&gt;# 遍历子目录，执行子目录下wscript里的do_sth&lt;/span&gt;
    ctx&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;exec_command(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;touch foo.txt&amp;#39;&lt;/span&gt;)
    ctx&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;msg(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;hello&amp;#39;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里函数参数ctx就是指向了Context的一个实例，而do_sth是作为Context上的一个方法而存在的，可以直观的理解为，我们为Context增加了一个自定义的do_sth方法，所以可以自由调用Context里本来提供的方法。&lt;/p&gt;
&lt;p&gt;./waf build执行时绑定的Context是BuildConetxt，在Build.py里被定义，在waf build的时候，执行的是wscript里&lt;code&gt;def build(bld)&lt;/code&gt;这个方法。举一个例子&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;configure&lt;/span&gt;(conf):
    conf&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;load(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;compiler_cxx&amp;#39;&lt;/span&gt;)
&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;build&lt;/span&gt;(bld):
    bld&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;shlib(source&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;a.cpp&amp;#39;&lt;/span&gt;, target&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;mylib3&amp;#39;&lt;/span&gt;)
    bld&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;program(source&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;main.cpp&amp;#39;&lt;/span&gt;, target&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;app&amp;#39;&lt;/span&gt;, use&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;mylib&amp;#39;&lt;/span&gt;)
    bld&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;stlib(target&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;foo&amp;#39;&lt;/span&gt;, source&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;b.cpp&amp;#39;&lt;/span&gt;)
    &lt;span style=&#34;color:#75715e&#34;&gt;# 直接调用bld&lt;/span&gt;
    bld(features &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;c cprogram glib2&amp;#39;&lt;/span&gt;,
        use      &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;GLIB GIO GOBJECT&amp;#39;&lt;/span&gt;,
        source   &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;main.c org.glib2.test.gresource.xml&amp;#39;&lt;/span&gt;,
        target   &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;gsettings-test&amp;#39;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里bld指向了BuildContext的一个实例，这意味着BuildContext里所有的方法都在这个函数里都是可用的，可以通过&lt;code&gt;bld.xxx&lt;/code&gt;来调用。&lt;/p&gt;
&lt;p&gt;值得注意的是，在Build.py中，可是找不到&lt;code&gt;shlib/probram/stlib&lt;/code&gt;这3个方法的，但是在这里却调用成功没有报错，这全部依赖于&lt;code&gt;conf.load(&#39;compiler_cxx&#39;)&lt;/code&gt;这一句。执行这句话后，就给bld指向的BuildContext实例绑定了&lt;code&gt;shlib/program/stlib&lt;/code&gt;这3个方法。
那直接调用&lt;code&gt;bld()&lt;/code&gt;呢？这个就要看Build.py里的&lt;code&gt;BuildContex():__call__&lt;/code&gt;方法了。从这里开始，就涉及到&lt;code&gt;TaskGen&lt;/code&gt;这个抽象了。&lt;/p&gt;
&lt;h2 id=&#34;taskgen--task&#34;&gt;TaskGen &amp;amp; Task&lt;/h2&gt;
&lt;p&gt;最终需要执行的编译指令、中间代码生成等，每一条都对应一个task，我们不可能去一个一个的写task，而是希望以一种声明式的方法表达想要做的事情，这就是task_gen所完成的任务。从声明式表达到生成task的这项任务，由waf build完成。在执行的过程中，会对搜集到的每个task_gen执行一下post()，然后这个task_gen就生成了自己所有的task。作为一个灵活的构建系统，waf提供了很多方法来让我们hook到post()的过程中。对于每个task，到底该不该执行需不需要执行，它自己会追踪自己的依赖，职责分离，我很喜欢这个设计思路。&lt;/p&gt;
&lt;p&gt;以前一小节为例，共在build(bld)里一共进行了4次调用，这意味着生成了4个task_gen的实例，在真正执行构建过程之前，会有一个地方对这4个实例各自调用一下post()，把所有的task_gen都消灭掉，变成task。至于怎么hook，这是个比较关键的点，如果理解了，就能很好的自定义waf了。&lt;/p&gt;
&lt;p&gt;首先看看写好的wscript，它的声明式体现在什么地方呢？体现在函数参数里。得益于python的语言特点，可以随便加参数，然后在函数实现里用**kw来取这些值。这意味着可以随便加自己想要的key=value进去，这些加进去的参数是可以在自定义的hook过程中取到的，这算是可自定义的一个基础。（ruby自定义的能力更强，毕竟dsl是其强项，但可能限于ruby的流行程度以及发行版是否默认安装，让作者最后选择了python，不过也已经够用了）&lt;/p&gt;
&lt;p&gt;在post()的过程中，会从&lt;code&gt;task_gen.meths[]&lt;/code&gt;里依次取出方法来执行，hook的方式就是把自定义的方法塞到这个&lt;code&gt;task_gen.meths[]&lt;/code&gt;之中。这只要在自定义的方法上加一个&lt;code&gt;@TaskGen.taskgen_method&lt;/code&gt;的注解就能实现，还是挺简洁的吧？声明式中写的key=val,都能通过taskgen.key取到，这样一来，几乎就获得了无限的能力来自定义构建过程了。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;taskgen.meths[]&lt;/code&gt;里有几项预定义的方法，waf也提供了指令来让我们定制自己方法执行的位置。总而言之，想要什么内容，直接在wscript里以key=val的方式指定，然后在自己的方法里用getattr来取就行了。&lt;/p&gt;
&lt;p&gt;这也只是个支持性框架，具体到某个语言(c/c++)是怎么做的，到后面再看。&lt;/p&gt;
&lt;h2 id=&#34;runner&#34;&gt;Runner&lt;/h2&gt;
&lt;p&gt;waf自己会默认起和cpu core相同数量的进程来执行构建认任务，而且构建过程的输出也很清晰漂亮。waf也提供了lazy的模式，不是一下子把所有的task_gen都转化，所以也是用了一些技巧来达成这个目的。在看waf代码的过程中，能看到很多pythonic和近乎炫技的技法，可见作者真是把python语言玩弄于股掌之中。&lt;/p&gt;
&lt;p&gt;如何实现&lt;code&gt;make -j&lt;/code&gt;的效果？答案是&lt;code&gt;Semphore&lt;/code&gt;，这里的job control是由几个类相互交互完成的。虽说Python的线程是鸡肋，但完成任务分派还是绰绰有余。这里分三类线程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;主线程，只有1个，即敲回车后生成的Python进程，其中负责交互的类为&lt;code&gt;Parallel&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;分派线程，也只有1个，叫&lt;code&gt;Spawner&lt;/code&gt;，与&lt;code&gt;Parallel&lt;/code&gt;互相引用。主线程决定了并行数量，然后在分派线程里初始化一个对应数量的&lt;code&gt;Semphore&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;工作线程&lt;code&gt;Consumer&lt;/code&gt;，有一个&lt;code&gt;Task&lt;/code&gt;，就得起1个&lt;code&gt;Consumer&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其实到现在的位置，要执行的&lt;code&gt;Task&lt;/code&gt;已经都放在一个队列&lt;code&gt;ready&lt;/code&gt;里了。遍历这个队列，acquire semphore，开新的&lt;code&gt;Consume&lt;/code&gt;执行&lt;code&gt;Task&lt;/code&gt;。如果&lt;code&gt;Semphore&lt;/code&gt;用完了，那么遍历的过程就阻塞，直到&lt;code&gt;Task&lt;/code&gt;执行结束后&lt;code&gt;Consumer&lt;/code&gt;再把这个&lt;code&gt;Semphore&lt;/code&gt;加回去。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Consume&lt;/code&gt;从&lt;code&gt;ready&lt;/code&gt;队列里获取任务执行，结束后放回&lt;code&gt;out&lt;/code&gt;队列里。主线程在一个循环里从&lt;code&gt;out&lt;/code&gt;往回拿任务，看看对不对，然后做一些统计或者直接结束构建。&lt;/p&gt;
&lt;p&gt;这里提到的所有类，都在Runner.py里。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Consumer&lt;/code&gt;里调用的方法最后都会走到Utils.run_regular_process里，通过subprocess.Popen来完成真正的命令调用。&lt;/p&gt;
&lt;h1 id=&#34;c的构建&#34;&gt;C++的构建&lt;/h1&gt;
&lt;p&gt;前面的核心抽象确实相当抽象，只是提供了一种框架来执行并行执行一些任务，关于构建本身则没有任何的提及。至于如何用这种工具做到构建C++工程，则并不是一件容易的事情。&lt;/p&gt;
&lt;p&gt;cmake社区近些年发起了轰轰烈烈的modern cmake的运动，即迁移到target based的构建描述，而非原先支持的流水帐构建。反观waf自带的C++构建方式，天然就是target based，只不过在waf的范畴里，这个叫task generator。&lt;/p&gt;
&lt;p&gt;C++代码最终的产出是什么呢？有3种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可执行程序&lt;/li&gt;
&lt;li&gt;静态库&lt;/li&gt;
&lt;li&gt;动态库&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有的C++程序其实是作为其他程序的依赖而存在，典型的比如各种libssl-dev。这种类型的产出不仅只有可加载的二进制，而且还要给其他库提供编译支持，即头文件。&lt;/p&gt;
&lt;p&gt;有人喜欢写all in one的代码，典型的比如Fabrice Bellard写quickjs，一个文件搞定。这种代码，其实并不太需要构建系统，几行shell脚本就全都搞定，反正每次都要重新编译。不过普通人还是选普通配置，该分模块就分模块，老老实实的一个一个module去完成功能。减少构建的时间，减少重复编译的工作，这就需要构建系统的辅助，来找出哪些需要重新编译而那些可以复用。&lt;/p&gt;
&lt;p&gt;可以从2个角度来思考C++的构建&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;找出来哪些需要重新构建，这个工作叫依赖管理&lt;/li&gt;
&lt;li&gt;每个构建应该怎么完成&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以如下的构建脚本为例吧。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;build&lt;/span&gt;(bld):
	bld&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;shlib(source&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;a.cpp b.cpp&amp;#39;&lt;/span&gt;, target&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;mylib&amp;#39;&lt;/span&gt;)
	bld&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;program(source&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;main.cpp&amp;#39;&lt;/span&gt;, target&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;app&amp;#39;&lt;/span&gt;, use&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;mylib&amp;#39;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里申明了一个动态库&lt;code&gt;mylib&lt;/code&gt;，由2个文件构建而成；然后申明了一个二进制的程序&lt;code&gt;app&lt;/code&gt;，用到了&lt;code&gt;mylib&lt;/code&gt;。
我们用手工编译的话，需要如下的步骤：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;$ g++ -c a.cpp -o a.o
$ g++ -c b.cpp -o b.o
$ g++ --shared a.o b.o -o mylib.so
$ g++ -c main.cpp -o main.o
$ g++ main.o -o app -lmylib
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中每一行就是一个task，那么如何从build里的那几句话得到这些task呢？说来话长，要用到waf提供的一系列脚手架，就一个一个慢慢来吧！&lt;/p&gt;
&lt;h2 id=&#34;task-generator解构&#34;&gt;Task Generator解构&lt;/h2&gt;
&lt;p&gt;这两次对bld.xxx的调用，生成了2个task generator，之后task_gen经过一系列的处理，生成了5个task。
不过，task generator到底是什么？看看文档里的说法吧！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;task generator应当有如下的特征&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;attribute(就是bld.shlib、bld.program的入参)仅在需要处理的时候才处理&lt;/li&gt;
&lt;li&gt;对attribute的存在性不做要求&lt;/li&gt;
&lt;li&gt;可以根据单个task generator来对构建过程做出调整&lt;/li&gt;
&lt;li&gt;应该提供与插件结合的能力&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以，实现这样的一个功能还是挺难的，文档里列举了这么一些方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用类来抽象task generator，通过继承的方式来解决添加功能的问题&lt;/li&gt;
&lt;li&gt;用python decorator来添加新功能，不过这种方式只能达到添加的功能，没办法删除已有的功能&lt;/li&gt;
&lt;li&gt;扁平化的方式，只声明自己功能执行的时候需要满足的条件，就像面向切片编程一样。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第3个看起来不错，不如看看是怎么实现的吧。&lt;/p&gt;
&lt;p&gt;要产出task，那么最开始的方法是什么？是&lt;code&gt;task_gen.post()&lt;/code&gt;，在BuildContext里被调用。这个方法其实只做了一件事情：根据设置的feature，填充task_gen.meths，处理一下里面顺序，然后挨个调用就行。&lt;/p&gt;
&lt;p&gt;那么就很明显了，对于所有的task generator，都有一个feature是&lt;code&gt;*&lt;/code&gt;，而与&lt;code&gt;*&lt;/code&gt;相互关联的方法只有2个:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@feature&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;*&amp;#39;&lt;/span&gt;)
&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;process_source&lt;/span&gt;(self):
    &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;处理&lt;/span&gt;bld&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;xyz(source&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;a.c b.py c.tex&amp;#39;&lt;/span&gt;)&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;的&lt;/span&gt;source

&lt;span style=&#34;color:#a6e22e&#34;&gt;@feature&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;*&amp;#39;&lt;/span&gt;)
&lt;span style=&#34;color:#a6e22e&#34;&gt;@before_method&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;process_source&amp;#39;&lt;/span&gt;)
&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;process_rule&lt;/span&gt;(self):
    &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;处理&lt;/span&gt;bld&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;xyz(rule&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;cp SRC[0] TGT[0]&amp;#39;&lt;/span&gt;)&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;的&lt;/span&gt;rule
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这就是waf所有魔法的起点。有了这2个方法，好像就有了锚点一样，如果有自己的功能想要添加，就用&lt;code&gt;@feature&lt;/code&gt;加上去，如果想要调整顺序，还有&lt;code&gt;@before_method\@after_method&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;extension-mapping&#34;&gt;extension mapping&lt;/h2&gt;
&lt;p&gt;在C++构建中，光有这些方法，离生成可用的task好像还有点远。其实并不远，只是需要明确到底是在哪一步hook进去的，这步就是前面提到的&lt;code&gt;process_source&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;process_source&lt;/code&gt;里，对source这个attribute里的每一个文件，都通过其后缀找到对应的处理函数并执行。c/c++代码的后缀无非就是c/cc/cxx/cpp/h/hpp/hxx之类的，这些waf自带的tool就已经把这些常用的都包含进去了。&lt;/p&gt;
&lt;p&gt;是不是有种，你以为我在第二层，其实我在第五层的感觉？实话说这就是我自己在追逻辑时候的感觉。如果feature是第一层，那么feature塞function到task_gen.meths里就是第二层；第二层提供了的一个方法&lt;code&gt;process_source&lt;/code&gt;是第三层，&lt;code&gt;process_source&lt;/code&gt;自己又提供了extension mapping，这就是第四层；对应到每一个extension，就可以到各自的构建过程了，这也是提供给其他的插件的hook点。&lt;/p&gt;
&lt;p&gt;真真儿的，有5层。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@TaskGen.extension&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;.cpp&amp;#39;&lt;/span&gt;,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;.cc&amp;#39;&lt;/span&gt;,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;.cxx&amp;#39;&lt;/span&gt;,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;.C&amp;#39;&lt;/span&gt;,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;.c++&amp;#39;&lt;/span&gt;)
&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;cxx_hook&lt;/span&gt;(self, node):
	&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Binds c++ file extensions to create :py:class:`waflib.Tools.cxx.cxx` instances&amp;#34;&lt;/span&gt;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;create_compiled_task(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;cxx&amp;#39;&lt;/span&gt;, node)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;看函数名就知道了，这里就是task真正产生的地方！&lt;/p&gt;
&lt;h1 id=&#34;后记&#34;&gt;后记&lt;/h1&gt;
&lt;p&gt;其实也不能完全算看完吧，还有很多具体的细节没有提到，典型的比如变动检测（用md5而没用update time，并且联系到一个动态ID上），动态编译build function（把run_str变成一个task的方法，执行这个方法调用subprocess.Popen），以及其他种种；不过已经可以稍微帮助别人理解一下这个构建工具的基本思想，以及一个稍微具体的实例来体会构建过程，希望能起到一点抛砖引玉的作用。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>TypeId in NS3</title>
      <link>https://ivkus.github.io/posts/ns3_typeid/</link>
      <pubDate>Sun, 29 Jul 2018 23:23:55 +0800</pubDate>
      
      <guid>https://ivkus.github.io/posts/ns3_typeid/</guid>
      <description>&lt;p&gt;NS3作为一个网络仿真库，出于性能的考量选择了C++。在写仿真程序时，不可避免的要对各种实体进行建模，自然C++中的class成了唯一可选的方案。不加任何技巧的class的确可以满足对某些实体的建模，可是在仿真软件的编写中需要有足够的动态性，比如有这样一些需求：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;动态的获知某个实体所具有的各类属性与属性的值&lt;/li&gt;
&lt;li&gt;这个实体的状态变化后引发一系列的动作&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这些都不是过分的需求，如果真的写过仿真程序的话肯定会非常渴求使用的软件能够提供实现这些需求的方法。要自己干巴巴的实现这些需求也不是不可以，比如可以提供一些查询接口来实现1；对于2的话，Qt的signal/slot或许可以实现。说到Qt了，其实QObject拥有了超越普通C++ class的能力，也都能满足上面指出的这些需求，但是其解决方案似乎有点重。&lt;/p&gt;
&lt;p&gt;幸好，NS3通过TypeId可以很好的解决上面提出的各类需求。&lt;/p&gt;
&lt;h1 id=&#34;typeid是什么&#34;&gt;&lt;code&gt;TypeId&lt;/code&gt;是什么&lt;/h1&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;TypdId&lt;/span&gt;
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint16_t&lt;/span&gt; m_tid;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这就是TypdId，就是这么简单。似乎有些不可思议，但&lt;code&gt;TypdId&lt;/code&gt;本身只是一个16bit的整型，之前提到的所有的复杂功能都是藏在&lt;code&gt;TypdId&lt;/code&gt;背后的&lt;code&gt;IidManager&lt;/code&gt;完成的，这个&lt;code&gt;m_tid&lt;/code&gt;只是作为一个索引而存在。&lt;/p&gt;
&lt;p&gt;TypdId提供了非常多的方法，比如说增加一个属性(&lt;code&gt;AddAttribute&lt;/code&gt;)，增加一个TraceSource(&lt;code&gt;AddTraceSource&lt;/code&gt;)，这些方法只是直接了当的将所需信息搜集起来转发给&lt;code&gt;IidManager&lt;/code&gt;。可以看个例子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;TypeId 
TypeId&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;AddAttribute (std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string name,
                      std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string help, 
                      &lt;span style=&#34;color:#66d9ef&#34;&gt;uint32_t&lt;/span&gt; flags,
                      &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; AttributeValue &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;initialValue,
                      Ptr&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; AttributeAccessor&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; accessor,
                      Ptr&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; AttributeChecker&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; checker,
                      SupportLevel supportLevel,
                      &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;supportMsg)
{
  NS_LOG_FUNCTION (&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; name &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; help &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; flags
                   &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;initialValue &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; accessor &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; checker
                   &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; supportLevel &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; supportMsg);
  IidManager&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;Get ()&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;AddAttribute (m_tid, name, help, flags,
                                    initialValue.Copy (), accessor, checker,
                                    supportLevel, supportMsg);
  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;基本上所有的&lt;code&gt;TypdId&lt;/code&gt;的方法都是这个样子。所以解决问题的核心其实是&lt;code&gt;IidManager&lt;/code&gt;。&lt;code&gt;IidManager&lt;/code&gt;可认为是一个类型数据库，保存了与&lt;code&gt;TypdId&lt;/code&gt;想关联的Attribute与TraceSource。具体的内部实现就太细节了，作为使用方是不需要也不应该去关注的。&lt;/p&gt;
&lt;h1 id=&#34;从使用角度看typdid&#34;&gt;从使用角度看&lt;code&gt;TypdId&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;正如在Qt中一样，想要使自己写的一个类拥有强大的能力，需要自己动手在类的声明中添加Q_OBJECT。在NS3设计的&lt;code&gt;TypeId&lt;/code&gt;系统中，这个步骤是要给自己的class添加一个静态方法&lt;code&gt;static TypeId GetTypeId (void)&lt;/code&gt;，然后在这个函数里返回一个&lt;code&gt;TypeId&lt;/code&gt;。在这个过程，可以尽情的使用&lt;code&gt;TypeId&lt;/code&gt;提供的各种方法来给本类加属性和TraceSource，唯一的限制就是这个返回的&lt;code&gt;TypeId&lt;/code&gt;应该是处于&lt;code&gt;GetTypeId&lt;/code&gt;里的静态变量，这是为了保证全局的唯一性。当然了，写C++的限制多了去了，这个规则应该归入这个NS3库的使用方法吧，不太值得吐槽。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TypeId&lt;/code&gt;对于我们平时写程序的最大的帮助在于，它可以给自己的类添加Attribute和TraceSource。&lt;/p&gt;
&lt;p&gt;Attribute可以代表该实体的一些属性，比如说一台PC的IP地址、一只猫的体重等。你可能会想，这个不就是一个Get函数的事儿么，值得专门搞这么一套复杂的系统么。其实还真值得：你会去写一个127.0.0.1还是2130706433？在NS3里，可以直接写127.0.0.1，这也得归功与这个Attribute系统。&lt;/p&gt;
&lt;p&gt;TraceSource可类比Qt的Signal，在需要的时候调用这个Functor（想不到更好的名称了，不过写C++的应该都知道这个东西），连到这个TraceSource的其他函数（所谓的Slot）就会被自动调用。好处自不必多说，要知道Qt能得到广泛的认可，Signal/Slot功不可没，NS3里的TraceSource系统就是Signal/Slot的翻版。&lt;/p&gt;
&lt;p&gt;还有一个使用限制就是，需要通过一个宏来告知系统我一个&lt;code&gt;TypeId&lt;/code&gt;要注册：&lt;code&gt;NS_OBJECT_ENSURE_REGISTERED&lt;/code&gt;。这个宏其实声明了一个静态类并同时声明了一个本文件内的静态实例。在这个静态类的构造函数中调用了我们定义的类的&lt;code&gt;GetTypeId&lt;/code&gt;，这就实现了自定义&lt;code&gt;TypeId&lt;/code&gt;的注册。&lt;/p&gt;
&lt;h1 id=&#34;attribute与tracesource&#34;&gt;Attribute与TraceSource&lt;/h1&gt;
&lt;p&gt;终于到重头戏了。其实这两部分的代码都切实的体现了C++罪恶的地方：模板与宏。一个新手要看懂这些代码要补充太多的东西了。说来惭愧，其实我自身也是一个新手，从开始接触这个库到现在能初步搞明白这样一个系统（真的只是大致初步明白），已经过去了3年多。这个系统的实现是模板里套宏、宏里套模板，看的时候需要时刻注意这段代码是宏生成的代码还是用了模板。&lt;/p&gt;
&lt;h2 id=&#34;attribute&#34;&gt;Attribute&lt;/h2&gt;
&lt;p&gt;前面提到了我们可以用127.0.0.1来代表ip的那32个bit，这就是Attribute系统的神奇所在。在这个例子里，127.0.0.1其实是一个字符串，Attribute系统可以把字符串转化为任何一种类型（可以是自定义类型）。&lt;/p&gt;
&lt;p&gt;就单纯的以这个地址类型来解释好了。我们的程序中需要使用IP地址，其最合适的存储方式其实是一个int，但IP地址最适合人类的表述方式其实是点分表示，我们自然也想在使用的时候用这种方式。那这个应该怎么做？&lt;/p&gt;
&lt;p&gt;首先先不管人怎么读写的问题，先考虑程序中的这个属性的使用方式。作为一个Ipv4的值，肯定有一些相关联的方法，比如说是否为广播地址、是否为多播地址、是否为本地地址之类类的。这些可以以用成员函数的方式实现，既然这样，那就尽情的实现吧！不需要考虑怎么集成到Attribute系统中去。同理，这个类里面有什么字段，想要什么字段就尽情的加。想必你也看出来了，我们在实现一个Attribute的时候，其实根本不需要考虑什么集成的问题。&lt;/p&gt;
&lt;p&gt;能够用ns3的方式来给一个对象设置属性的这个能力依赖与3个基本的组件&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;AttributeValue&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AttributeAccessor&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AttributeChecker&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;首先看看什么是ns3的方式为一个对象设置属性，看一下官方manual里的例子&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;Ptr&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ConfigExample&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; a2_obj &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; CreateObject&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ConfigExample&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; ();
a2_obj&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;SetAttribute (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;TestInt16&amp;#34;&lt;/span&gt;, IntegerValue (&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;));
IntegerValue iv;
a2_obj&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;GetAttribute (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;TestInt16&amp;#34;&lt;/span&gt;, iv);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;第一行创建了新的对象&lt;code&gt;ConfigExample&lt;/code&gt;，并存在指针&lt;code&gt;a2_obj&lt;/code&gt;里。第二行就是所谓的ns3的方式设置属性，依赖于一个方法&lt;code&gt;SetAttriute&lt;/code&gt;。这个方法属于&lt;code&gt;ObjectBase&lt;/code&gt;，所有能用&lt;code&gt;Ptr&lt;/code&gt;指向的对象都是&lt;code&gt;objectBase&lt;/code&gt;的子类。所以说，在调用&lt;code&gt;SetAttribute&lt;/code&gt;时，除去C++的语法糖，这句话完整的形式是这样的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;SetAttribute (a2_obj, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;TestInt16&amp;#34;&lt;/span&gt;, IntegerValue (&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;好了，我们跳进去看看实现&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;
ObjectBase&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;SetAttribute (std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string name, &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; AttributeValue &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;value)
{
  NS_LOG_FUNCTION (&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; name &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;value);
  &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;TypeId&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;AttributeInformation info;
  TypeId tid &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; GetInstanceTypeId ();
  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;tid.LookupAttributeByName (name, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;info))
    {
      NS_FATAL_ERROR (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Attribute name=&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;name&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; does not exist for this object: tid=&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;tid.GetName ());
    }
  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;(info.flags &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; TypeId&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;ATTR_SET) &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt;
      &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;info.accessor&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;HasSetter ())
    {
      NS_FATAL_ERROR (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Attribute name=&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;name&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; is not settable for this object: tid=&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;tid.GetName ());
    }
  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;DoSet (info.accessor, info.checker, value))
    {
      NS_FATAL_ERROR (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Attribute name=&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;name&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; could not be set for this object: tid=&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;tid.GetName ());
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个方法是对象自己身上的方法，所以要记住&lt;code&gt;this&lt;/code&gt;这时候指向的是谁：这里就是&lt;code&gt;a2_obj&lt;/code&gt;。这个方法也很直白&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先能通过&lt;code&gt;GetInstanceTypdId()&lt;/code&gt;拿到真正的、&lt;code&gt;ConfigExample&lt;/code&gt;的&lt;code&gt;TypeId&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;拿到&lt;code&gt;AttributeInformation&lt;/code&gt;，就有了&lt;code&gt;accessor&lt;/code&gt;、&lt;code&gt;checker&lt;/code&gt;，还有作为参数传进来的值&lt;code&gt;value&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DoSet&lt;/code&gt;做了实际的设置工作&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;再看看&lt;code&gt;DoSet&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;
ObjectBase&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;DoSet (Ptr&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; AttributeAccessor&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; accessor, 
                   Ptr&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; AttributeChecker&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; checker,
                   &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; AttributeValue &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;value)
{
  NS_LOG_FUNCTION (&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; accessor &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; checker &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;value);
  Ptr&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;AttributeValue&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; v &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; checker&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;CreateValidValue (value);
  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (v &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
    {
      &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; false;
    }
  &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; ok &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; accessor&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;Set (&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;v);
  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; ok;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;检查什么的就不说了，最让人关心的是这个方法&lt;code&gt;accessor-&amp;gt;Set (this, *v)&lt;/code&gt;。这个方法是怎么定义的，是哪里来的？这下欢迎进入模板与宏的世界。&lt;/p&gt;
&lt;h3 id=&#34;attributeaccessor&#34;&gt;&lt;code&gt;AttributeAccessor&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;答案是这个这个方法是属于&lt;code&gt;accessor&lt;/code&gt;的，而&lt;code&gt;accessor&lt;/code&gt;的定义是在注册TypeId的时候生成的。RTFSC：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ConfigExample&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; Object
{
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; TypeId GetTypeId (&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; TypeId tid &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; TypeId (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ns3::A&amp;#34;&lt;/span&gt;)
      .SetParent&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Object&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; ()
      .AddAttribute (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;TestInt16&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;help text&amp;#34;&lt;/span&gt;,
                     IntegerValue (&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;),
                     MakeIntegerAccessor (&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;A&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;m_int16),
                     MakeIntegerChecker&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int16_t&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; ())
      ;
      &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; tid;
    }
  &lt;span style=&#34;color:#66d9ef&#34;&gt;int16_t&lt;/span&gt; m_int16;
};

NS_OBJECT_ENSURE_REGISTERED (ConfigExample);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;看到那句&lt;code&gt;MakeIntegerAccessor (&amp;amp;A::m_int16)&lt;/code&gt;了么？搞懂了这个，其实就能搞懂ns3的套路了，再看其他的机制也就顺风顺水了。我们慢慢来，一步一步来，保证每一步都有始有终，不会出现跳跃的现象。这个过程稍微有点冗长，可以去拿包零食边吃边看了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MakeIntegerAccessor&lt;/code&gt;是可调用的一个“东西”。回想一下C++可调用的东西有哪些？1. 函数，2. Functor，就是实现了自定义operator()的一个class的实例。3.实例化一个类型看起来也像是函数调用。我用的Eclipse，f3跳转到定义，等我过去的时候傻眼了：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;ATTRIBUTE_ACCESSOR_DEFINE (Integer);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;好家伙，看来要展开这个看看了，ctrl+=让它现形：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; T1&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;                                                \
Ptr&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; AttributeAccessor&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; MakeIntegerAccessor (T1 a1)              \
{                                                                     \
  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; MakeAccessorHelper&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;IntegerValue&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; (a1);                       \
}                                                                     \
&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; T1, &lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; T2&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;                                   \
Ptr&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; AttributeAccessor&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; MakeIntegerAccessor (T1 a1, T2 a2)       \
{                                                                     \
  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; MakeAccessorHelper&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;IntegerValue&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; (a1, a2);                   \
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这展开了2个函数，到这时可以确定，&lt;code&gt;MakeIntegerAccessor&lt;/code&gt;是一个函数，而且我们调用的是只有一个入参的那个函数，这个函数返回了一个&lt;code&gt;AttributeAccessor&lt;/code&gt;的智能指针。具体的展开过程就不细讲了，也没有讲的必要，看看&lt;code&gt;ATTRIBUTE_ACCESSOR_DEFINE&lt;/code&gt;的定义就明白了。现在需要关心的是我们现在调用的函数里有个&lt;code&gt;T1&lt;/code&gt;，要搞明白这个&lt;code&gt;T1&lt;/code&gt;的类型是什么。&lt;/p&gt;
&lt;p&gt;重新回头看看&lt;code&gt;MakeIntegerAccessor (&amp;amp;A::m_int16)&lt;/code&gt;，这里的&lt;code&gt;T1&lt;/code&gt;就是&lt;code&gt;&amp;amp;A::m_int16&lt;/code&gt;的类型。先就此打住，这个结论先记下来。我们继续追下去，这下应该看真正的实现&lt;code&gt;MakeAccessorHelper&amp;lt;IntegerValue&amp;gt; (a1)&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 第一种实现
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; V, &lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; T, &lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; U&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;inline&lt;/span&gt;
Ptr&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; AttributeAccessor&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
DoMakeAccessorHelperOne (U T&lt;span style=&#34;color:#f92672&#34;&gt;::*&lt;/span&gt;memberVariable)

&lt;span style=&#34;color:#75715e&#34;&gt;// 第二种实现
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; V, &lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; T, &lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; U&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;inline&lt;/span&gt;
Ptr&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; AttributeAccessor&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
DoMakeAccessorHelperOne (U (T&lt;span style=&#34;color:#f92672&#34;&gt;::*&lt;/span&gt;getter)(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt;)

&lt;span style=&#34;color:#75715e&#34;&gt;// 第三种实现
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; V, &lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; T, &lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; U&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;inline&lt;/span&gt;
Ptr&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; AttributeAccessor&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
DoMakeAccessorHelperOne (&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; (T&lt;span style=&#34;color:#f92672&#34;&gt;::*&lt;/span&gt;setter)(U))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;结果就是匹配到了第一种实现。
其实我曾经很多次追到了这里，却没看懂这里的类型到底是什么意思。也不知道什么时候忽然就明白了。&lt;code&gt;A::m_int16&lt;/code&gt;对应于&lt;code&gt;U T::*&lt;/code&gt;，是个正常人第一眼看上去绝对不会明白这到底是怎么联系在一起的，我也是正常人，所以我现在也不明白这种怪异的语法到底是谁第一次使用的。&lt;code&gt;T&lt;/code&gt;对应于&lt;code&gt;A&lt;/code&gt;，那么&lt;code&gt;U&lt;/code&gt;应该是对应于&lt;code&gt;m_int16&lt;/code&gt;。这个类型能代表一个类里的一个成员变量的类型，&lt;code&gt;T&lt;/code&gt;表明了它是一个类的成员变量，&lt;code&gt;U&lt;/code&gt;表明了这个变量的类型是&lt;code&gt;uint16_t&lt;/code&gt;，现在就只能这么死记了，要想真正搞明白我觉得应该去翻一下编译器里前端到底是怎么解析这个鬼畜般的语法的，先就这么囫囵吞枣吧！对于另外的两个反而更好懂一点，那个类型和平时用的函数指针类型声明挺像的，反而不用多说。一个是&lt;code&gt;getter&lt;/code&gt;，说明这个attribute只提供了获取的接口；一个是setter，说明这个&lt;code&gt;attribute&lt;/code&gt;只能设置不能获取。当然了，这是站在ns3的使用方式上说的，直接强行用c++的方式赋值不在我们的讨论范围之内。&lt;/p&gt;
&lt;p&gt;这3个函数都返回了一个指向&lt;code&gt;AttributeAccessor&lt;/code&gt;的指针。现在来看看实现吧！&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;Ptr&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; AttributeAccessor&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
DoMakeAccessorHelperOne (U T&lt;span style=&#34;color:#f92672&#34;&gt;::*&lt;/span&gt;memberVariable)
{
  &lt;span style=&#34;color:#75715e&#34;&gt;/* AttributeAcessor implementation for a class member variable. */&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;MemberVariable&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; AccessorHelper&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T,V&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
  {
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
    &lt;span style=&#34;color:#75715e&#34;&gt;/*
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     * Construct from a class data member address.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     * \param [in] memberVariable The class data member address.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     */&lt;/span&gt;
    MemberVariable (U T&lt;span style=&#34;color:#f92672&#34;&gt;::*&lt;/span&gt;memberVariable)
      &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; AccessorHelper&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T,V&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; (),
        m_memberVariable (memberVariable)
    {}
&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;virtual&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; DoSet (T &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;object, &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; V &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;v) &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; {
      &lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; AccessorTrait&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;U&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;::&lt;/span&gt;Result tmp;
      &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; ok &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; v&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;GetAccessor (tmp);
      &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;ok)
        {
          &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; false;
        }
      (object&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;*&lt;/span&gt;m_memberVariable) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; tmp;
      &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; true;
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;virtual&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;DoGet&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; T &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;object, V &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;v) &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; {
      v&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;Set (object&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;*&lt;/span&gt;m_memberVariable);
      &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; true;
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;virtual&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;HasGetter&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; {
      &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; true;
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;virtual&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;HasSetter&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; {
      &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; true;
    }

    U T&lt;span style=&#34;color:#f92672&#34;&gt;::*&lt;/span&gt;m_memberVariable;  &lt;span style=&#34;color:#75715e&#34;&gt;// Address of the class data member.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  };
  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; Ptr&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; AttributeAccessor&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; MemberVariable (memberVariable), false);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;照样很鬼畜。这是在函数里定义了一个类，并且返回了指向这个类的只能指针。这个类继承自&lt;code&gt;AccessorHelper&lt;/code&gt;，而&lt;code&gt;AccessorHelper&lt;/code&gt;又继承自&lt;code&gt;AttributeAccessor&lt;/code&gt;。所以将其作为&lt;code&gt;AttributeAccessor&lt;/code&gt;的子类返回也说得过去。&lt;/p&gt;
&lt;p&gt;至于为什么要继承这么多？我现在的理解是这样的&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;AttributeAccessor&lt;/code&gt;只是一个纯虚接口，它只定义了作为Accessor应当具有的接口。在Java里的话，估计这就是个Interface。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AccessorHelper&lt;/code&gt;提供了&lt;code&gt;Set&lt;/code&gt;和&lt;code&gt;Get&lt;/code&gt;的默认实现，把一些可变的部分留给了它的子类来实现，这些可变的部分是&lt;code&gt;DoSet&lt;/code&gt;和&lt;code&gt;DoGet&lt;/code&gt;。所以在&lt;code&gt;MemberVariable&lt;/code&gt;要实现&lt;code&gt;DoSet&lt;/code&gt;和&lt;code&gt;DoGet&lt;/code&gt;。这应该是某种设计模式，看看那本书就能找到了。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;到现在为止，我们知道可以造出来一个&lt;code&gt;AttributeAccessor&lt;/code&gt;，并把指向这个&lt;code&gt;AttributeAccessor&lt;/code&gt;的指针存在了我们的&lt;code&gt;IidManager&lt;/code&gt;的数据库中。以后想要拿出来这个&lt;code&gt;AttributeAccessor&lt;/code&gt;，就要手拿&lt;code&gt;TypeId&lt;/code&gt;去找&lt;code&gt;IidManager&lt;/code&gt;去要，而且要到的也是一个指针，这个指针指向了在&lt;code&gt;return Ptr&amp;lt;const AttributeAccessor&amp;gt; (new MemberVariable (memberVariable), false);&lt;/code&gt;这句话里的那个new出来的地址。&lt;/p&gt;
&lt;p&gt;总结一下，一个类型的&lt;code&gt;AttributeAccessor&lt;/code&gt;只有一个，就是那个new出来的地方。程序其他地方都是拿指针去访问的。在那块地址存的东西只有两样（只考虑我们现在这个membervariable类型的accessor）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;U T::*m_memberVariable&lt;/code&gt;的值，这个值代表了这个变量在拥有&lt;code&gt;TypeId&lt;/code&gt;那个类里的偏移量&lt;/li&gt;
&lt;li&gt;一个虚表指针。因为是有virtual函数，所以这个&lt;code&gt;AttributeAccessor&lt;/code&gt;的实例是有虚表指针的，这个虚表里就是真正的、对应类型的函数实现。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;回头看看那个&lt;code&gt;DoSet&lt;/code&gt;，里面那个accessor到底是什么应该已经清楚了。那个个accessor的&lt;code&gt;Set&lt;/code&gt;方法在哪儿定义的？答案是&lt;code&gt;AccessorHelper&lt;/code&gt;。我直接把结论公开了，但是你现在应该停下来去看看具体的实现。&lt;code&gt;AttributeAccessor&lt;/code&gt;-&amp;gt;&lt;code&gt;AccessorHelper&lt;/code&gt;-&amp;gt;&lt;code&gt;DoMakeAccessorHelperOne()里的MemberVariable&lt;/code&gt;这是一条继承链，到了最下一层的时候所有的方法都已经定义，只是在不同的层次提供了不同的实现。&lt;/p&gt;
&lt;p&gt;假设你已经搞明白&lt;code&gt;Accessor&lt;/code&gt;的继承链条了，也明白这个&lt;code&gt;Accessor&lt;/code&gt;到底支持什么操作，我们就进入了真正执行&lt;code&gt;Set&lt;/code&gt;的地方：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// DoMakeAccessorHelperOne()里的MemberVariable的方法
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;virtual&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;DoSet&lt;/span&gt; (T &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;object, &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; V &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;v) &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; {
  &lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; AccessorTrait&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;U&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;::&lt;/span&gt;Result tmp;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; ok &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; v&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;GetAccessor (tmp);
  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;ok)
    {
      &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; false;
    }
  (object&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;*&lt;/span&gt;m_memberVariable) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; tmp;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; true;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里的&lt;code&gt;V *v&lt;/code&gt;就是&lt;code&gt;myObj-&amp;gt;SetAttribute (&amp;quot;MyIntAttribute&amp;quot;, IntegerValue(3));&lt;/code&gt;里的&lt;code&gt;IntegerValue(3)&lt;/code&gt;。要是没看懂，就去翻代码。这个结论是必须要搞懂的，不然就没有进行下去的必要了。&lt;/p&gt;
&lt;p&gt;其实&lt;code&gt;Accessor&lt;/code&gt;的世界已经探索的差不多了，为了真正搞明白这个函数做了什么，我们先转向看看&lt;code&gt;AttributeValue&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;attributevalue&#34;&gt;&lt;code&gt;AttributeValue&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;NS3的套路是什么？用宏和模板做代码生成。这个套路在&lt;code&gt;AttributeValue&lt;/code&gt;里也是一样的。自定义了一个&lt;code&gt;AttributeValue&lt;/code&gt;需要写一个宏，这个宏帮助我们做了大部分的事情。拿那个&lt;code&gt;IntegerValue&lt;/code&gt;说事儿:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;ATTRIBUTE_VALUE_DEFINE_WITH_NAME (&lt;span style=&#34;color:#66d9ef&#34;&gt;uint64_t&lt;/span&gt;, Uinteger);
&lt;span style=&#34;color:#75715e&#34;&gt;// 在头文件里写这个宏，能够展开为如下的定义
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;UintegerValue&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; AttributeValue                             \
  {                                                                     \
  &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;                                                               \
    UintegerValue ();                                                   \
    UintegerValue (&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;uint64_t&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;value);                              \
    &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Set&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;uint64_t&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;value);                                   \
    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint64_t&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Get&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt;;                                          \
    &lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;                                               \
      &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; GetAccessor (T &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;value) &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; {                               \
      value &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; T (m_value);                                              \
      &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; true;                                                      \
    }                                                                   \
    &lt;span style=&#34;color:#66d9ef&#34;&gt;virtual&lt;/span&gt; Ptr&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;AttributeValue&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; Copy (&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt;;                      \
    &lt;span style=&#34;color:#66d9ef&#34;&gt;virtual&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string                                                 \
      SerializeToString (Ptr&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; AttributeChecker&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; checker) &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt;;    \
    &lt;span style=&#34;color:#66d9ef&#34;&gt;virtual&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;                                                        \
      DeserializeFromString (std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string value,                         \
                             Ptr&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; AttributeChecker&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; checker);      \
  &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;                                                              \
    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint64_t&lt;/span&gt; m_value;                                                   \
  }

&lt;span style=&#34;color:#75715e&#34;&gt;// 上述定义的实现仰赖于对于cc文件里的实现，也是用宏
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;ATTRIBUTE_VALUE_IMPLEMENT_WITH_NAME (&lt;span style=&#34;color:#66d9ef&#34;&gt;uint64_t&lt;/span&gt;,Uinteger);

&lt;span style=&#34;color:#75715e&#34;&gt;// 展开后是这样的
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;UintegerValue&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;UintegerValue ()                                         \
    &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; m_value () {}                                                     \
  UintegerValue&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;UintegerValue (&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;uint64_t&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;value)                  \
    &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; m_value (value) {}                                                \
  &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; UintegerValue&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;Set (&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;uint64_t&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;v) {                         \
    m_value &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; v;                                                        \
  }                                                                     \
  &lt;span style=&#34;color:#66d9ef&#34;&gt;uint64_t&lt;/span&gt;  UintegerValue&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;Get (&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; {                           \
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; m_value;                                                     \
  }                                                                     \
  Ptr&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;AttributeValue&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;                                                   \
  UintegerValue&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;Copy (&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; {                                    \
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; ns3&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;Create&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;UintegerValue&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;);                          \
  }                                                                     \
  std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string UintegerValue&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;SerializeToString                          \
    (Ptr&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; AttributeChecker&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; checker) &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; {                       \
      std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;ostringstream oss;                                           \
      oss &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; m_value;                                                   \
      &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; oss.str ();                                                \
  }                                                                     \
  &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; UintegerValue&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;DeserializeFromString                             \
    (std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string value, Ptr&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; AttributeChecker&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; checker) {          \
      std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;istringstream iss;                                           \
      iss.str (value);                                                  \
      iss &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; m_value;                                                   \
      &lt;span style=&#34;color:#66d9ef&#34;&gt;do&lt;/span&gt; {                                                                 \
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;(iss.eof ()))                                                          \
      {                                                                \
        std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cerr &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;aborted. cond=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;!(iss.eof ())&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;, &amp;#34;&lt;/span&gt;;           \
        &lt;span style=&#34;color:#66d9ef&#34;&gt;do&lt;/span&gt;                                                    \
    {                                                   \
      std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cerr &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;msg=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Attribute value &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; value &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;  \
                           &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; is not properly formatted&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;, &amp;#34;&lt;/span&gt;;           \
      &lt;span style=&#34;color:#66d9ef&#34;&gt;do&lt;/span&gt;                                                      \
    {                                                     \
      std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cerr &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;file=&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;D:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\\&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;Code&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\\&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;ns-allinone-3.28&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\\&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;ns-3.28&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\\&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;src&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\\&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;core&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\\&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;model&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\\&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;uinteger.cc&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;, line=&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;    \
        &lt;span style=&#34;color:#ae81ff&#34;&gt;35&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;endl;                            \
      &lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;ns3&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;FatalImpl&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;FlushStreams ();                  \
      &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (true) std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;terminate ();                       \
    }                                                     \
  &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (false);               \
    }                                                   \
  &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (false);                                          \
      }                                                                \
  } &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (false);            \
      &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;iss.bad () &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;iss.fail ();                               \
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;具体的展开过程感兴趣的可以去追一下，要是没有IDE的帮助，要展开一个这么复杂的宏也还是需要一点时间的。结合之前accessor的内容(&lt;code&gt;v-&amp;gt;GetAccessor&lt;/code&gt;)，这个函数就定义在了这里（头文件里作为模板类成员函数实现了）。&lt;/p&gt;
&lt;p&gt;值得一看的倒是那两个&lt;code&gt;SerializeToString&lt;/code&gt;和&lt;code&gt;DeserializerFromString&lt;/code&gt;。这两个函数完成了字符串到实际定义类型的转换，里面用到了&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;的重载，所以这也是为什么在自定义属性的时候要去实现全局&lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt;的原因了。通过这两个函数，我们就可以用一个字面意义上的127.0.0.1去设置一个IP，而非2130706433。其实这个系统在解析string的时候出了一点小bug被我发现了，也算是对开源的一点点小贡献吧!(&lt;a href=&#34;https://www.nsnam.org/bugzilla/show_bug.cgi?id=2447&#34;&gt;https://www.nsnam.org/bugzilla/show_bug.cgi?id=2447&lt;/a&gt;) 这个bug在ns3.25里提出来，之后应该是修好了。&lt;/p&gt;
&lt;p&gt;还剩一个&lt;code&gt;AttributeChecker&lt;/code&gt;，但这个好像不影响对系统的理解，就不去看啦！想必搞明白套路之后，要看懂也不是什么难事儿啦！&lt;/p&gt;
&lt;h2 id=&#34;tracesource&#34;&gt;&lt;code&gt;TraceSource&lt;/code&gt;&lt;/h2&gt;
&lt;h3 id=&#34;callback杂谈&#34;&gt;&lt;code&gt;Callback&lt;/code&gt;杂谈&lt;/h3&gt;
&lt;p&gt;说起TraceSource，那么&lt;code&gt;Callback&lt;/code&gt;就是绕不过去的坎。可以作为一个&lt;code&gt;TraceSource&lt;/code&gt;的属性关联一个&lt;code&gt;TracedCallback&lt;/code&gt;类型，用于通知自身值的改变。&lt;code&gt;TracedCallback&lt;/code&gt;只是一个&lt;code&gt;Callback&lt;/code&gt;的容器，里面有一个&lt;code&gt;std::list&amp;lt;Callback&amp;gt;&lt;/code&gt;用于存放连接到该&lt;code&gt;TraceSource&lt;/code&gt;的函数。一个&lt;code&gt;TraceSource&lt;/code&gt;可以连接多次，每次它被&lt;code&gt;Connect&lt;/code&gt;一次，就会往这个list里填一个元素。当然，这个元素就是一个&lt;code&gt;Callback&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Callback&lt;/code&gt;类本身只是提供了创建的接口于调用接口。调用接口就是对各个&lt;code&gt;operator()&lt;/code&gt;的重载，最多有9个参数，也因此有9个&lt;code&gt;operator()&lt;/code&gt;。这种情况在&lt;code&gt;c++11&lt;/code&gt;之后应该会有更好的写法，只是我并不知道怎么写罢了。&lt;code&gt;Callback&lt;/code&gt;继承自&lt;code&gt;CallbackBase&lt;/code&gt;，这里存放了真正的指向实现(&lt;code&gt;CallbackImplBase&lt;/code&gt;)的指针。&lt;/p&gt;
&lt;p&gt;怎么&lt;code&gt;CallbaciImpl&lt;/code&gt;还有继承？从&lt;code&gt;Callback&lt;/code&gt;开始已经跳转两次了还没见到真正的实现，其实这也不远了，&lt;code&gt;CallbackImplBase&lt;/code&gt;说到底就是一个&lt;code&gt;Interface&lt;/code&gt;一样的东西，对&lt;code&gt;CallbackImpl&lt;/code&gt;做了一些限定，这样继承了&lt;code&gt;CallbackImpl&lt;/code&gt;的子类就能以比较一致的方法去操作。其实&lt;code&gt;CallbackImplBase&lt;/code&gt;-&amp;gt;&lt;code&gt;CallbackImpl&lt;/code&gt;-&amp;gt;各种具体的&lt;code&gt;CallbackImpl&lt;/code&gt;弄这么复杂也是无奈之举。抽出来中间的&lt;code&gt;CallbackImpl&lt;/code&gt;是为了实现多输入参数类型的&lt;code&gt;operator()&lt;/code&gt;的重载，考虑到这个库的编写时间，那时候的c++模板编程好像没有c++11之后的那么完善，没有可变长类型参数，这样做也是无可厚非。我想如果用最新的&lt;code&gt;c++11&lt;/code&gt;之后的标准来写，这个&lt;code&gt;Callback&lt;/code&gt;可能就不会这么难以理解了，似乎可以直接采用&lt;code&gt;std::function&lt;/code&gt;或者只是做一些小的改动就可以了。不管怎样，到了&lt;code&gt;CallbackImpl&lt;/code&gt;这个层级时，单单&lt;code&gt;CallbackImpl&lt;/code&gt;这个名字就已经可以支撑多达9个入参的&lt;code&gt;operator()&lt;/code&gt;了，再下面层级的类就可以方便的享用这种便利，这也是为什么&lt;code&gt;MemPtrCallbackImpl&lt;/code&gt;、&lt;code&gt;FunctorCallbackImpl&lt;/code&gt;等子类可以在一个class里就重载多次&lt;code&gt;operator()&lt;/code&gt;同时还能做类型检查的原因了。&lt;/p&gt;
&lt;h3 id=&#34;tracedvalue追踪&#34;&gt;&lt;code&gt;TracedValue&lt;/code&gt;追踪&lt;/h3&gt;
&lt;p&gt;先来看看在&lt;code&gt;TypeId&lt;/code&gt;里怎么使用&lt;code&gt;TraceSource&lt;/code&gt;吧！我随便从代码里摘了一条出来&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;.AddTraceSource (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Tx&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;A new packet is created and is sent&amp;#34;&lt;/span&gt;,
                MakeTraceSourceAccessor (&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;BulkSendApplication&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;m_txTrace),
                &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ns3::Packet::TracedCallback&amp;#34;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;又看到了熟悉的&lt;code&gt;Accessor&lt;/code&gt;，这个&lt;code&gt;Accessor&lt;/code&gt;为的就是能拿到类里的一个成员变量。所幸对于&lt;code&gt;TraceSource&lt;/code&gt;来说，只存在访问&lt;code&gt;Get&lt;/code&gt;而不存在设置&lt;code&gt;Set&lt;/code&gt;，这个&lt;code&gt;Accessor&lt;/code&gt;相比起&lt;code&gt;AttributeAccessor&lt;/code&gt;来说要简单一些。追到代码里看到的还是熟悉的的套路：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
Ptr&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; TraceSourceAccessor&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; MakeTraceSourceAccessor (T a)
{
  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;DoMakeTraceSourceAccessor&lt;/span&gt; (a);
}
&lt;span style=&#34;color:#75715e&#34;&gt;// DoMakeTraceSourceAccessor的实现
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 在函数内部定义新的类，这个类实现了TraceSourceAccessor的接口
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 因为`TraceSource`只有一种类型，这种类型就是
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// “类内部的成员变量”
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 所以可以看到函数的签名就只有一种
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// SOURCE T::a
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// sigh...又是这个鬼畜的标记
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; T, &lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; SOURCE&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
Ptr&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; TraceSourceAccessor&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; 
DoMakeTraceSourceAccessor (SOURCE T&lt;span style=&#34;color:#f92672&#34;&gt;::*&lt;/span&gt;a)
{
  &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Accessor&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; TraceSourceAccessor
  {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;virtual&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ConnectWithoutContext&lt;/span&gt; (ObjectBase &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;obj, &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; CallbackBase &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;cb) &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; {
      T &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;p &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;dynamic_cast&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;*&amp;gt;&lt;/span&gt; (obj);
      &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (p &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
        {
          &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; false;
        }
      (p&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;*&lt;/span&gt;m_source).ConnectWithoutContext (cb);
      &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; true;
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;virtual&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Connect&lt;/span&gt; (ObjectBase &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;obj, std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string context, &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; CallbackBase &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;cb) &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; {
      T &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;p &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;dynamic_cast&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;*&amp;gt;&lt;/span&gt; (obj);
      &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (p &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
        {
          &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; false;
        }
      (p&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;*&lt;/span&gt;m_source).Connect (cb, context);
      &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; true;
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;virtual&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;DisconnectWithoutContext&lt;/span&gt; (ObjectBase &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;obj, &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; CallbackBase &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;cb) &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; {
      T &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;p &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;dynamic_cast&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;*&amp;gt;&lt;/span&gt; (obj);
      &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (p &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
        {
          &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; false;
        }
      (p&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;*&lt;/span&gt;m_source).DisconnectWithoutContext (cb);
      &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; true;
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;virtual&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Disconnect&lt;/span&gt; (ObjectBase &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;obj, std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string context, &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; CallbackBase &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;cb) &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; {
      T &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;p &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;dynamic_cast&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;*&amp;gt;&lt;/span&gt; (obj);
      &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (p &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
        {
          &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; false;
        }
      (p&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;*&lt;/span&gt;m_source).Disconnect (cb, context);
      &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; true;
    }
    SOURCE T&lt;span style=&#34;color:#f92672&#34;&gt;::*&lt;/span&gt;m_source;
  } &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;accessor &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Accessor ();
  accessor&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;m_source &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; Ptr&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; TraceSourceAccessor&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; (accessor, false);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;TraceSource&lt;/code&gt;存在的理由就是要触发其他的逻辑的，因此要提供挂接其他逻辑的方法，即&lt;code&gt;Connect&lt;/code&gt;。这里的&lt;code&gt;Accessor&lt;/code&gt;只是简单的把&lt;code&gt;Connect&lt;/code&gt;的请求转发给了&lt;code&gt;TraceSource&lt;/code&gt;。好几个类都有&lt;code&gt;Connect&lt;/code&gt;，一不小心就晕头转向了，现在可以总结一下不同类的&lt;code&gt;Connect&lt;/code&gt;到底做了什么，以及它们究竟时何时被调用的。&lt;/p&gt;
&lt;p&gt;假设现在已经有一个ns3的类&lt;code&gt;MyObject&lt;/code&gt;（fifth.cc)，也继承了Object，意味着它实现了&lt;code&gt;GetTypeId&lt;/code&gt;，拥有了&lt;code&gt;Attribute&lt;/code&gt;和&lt;code&gt;TraceSource&lt;/code&gt;的能力。它有一个可以被trace的值&lt;code&gt;m_myInt&lt;/code&gt;。这个值不是简单的类型，而是一个&lt;code&gt;TracedValue&amp;lt;int32_t&amp;gt; m_myInt;&lt;/code&gt;。这样的话，只要对&lt;code&gt;m_myInt&lt;/code&gt;进行赋值，Trace系统就可以工作了。给这个&lt;code&gt;m_myInt&lt;/code&gt;赋值的话会调用什么？当然是&lt;code&gt;operator=&lt;/code&gt;了。跳到&lt;code&gt;TracedValue&lt;/code&gt;的对应实现看看：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;TracedValue &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;operator&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; TracedValue &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;o) {
  TRACED_VALUE_DEBUG (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;x=&amp;#34;&lt;/span&gt;);
  Set (o.m_v);
  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;;
}

&lt;span style=&#34;color:#75715e&#34;&gt;// 关键就在`Set`里了，里面肯定有触发`Callback`的代码
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Set&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; T &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;v) {
  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (m_v &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; v)
    {
      m_cb (m_v, v);
      m_v &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; v;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;果然，有个&lt;code&gt;m_cb&lt;/code&gt;，这就是我们之前提到的&lt;code&gt;TracedCallback&lt;/code&gt;。每次给这个&lt;code&gt;m_myInt&lt;/code&gt;赋值，就会调用&lt;code&gt;m_cb&lt;/code&gt;通知这个值已经变化。可以看到，&lt;code&gt;TracedValue&lt;/code&gt;本身提供了一个&lt;code&gt;Connect&lt;/code&gt;的方法，这意味着我们可以直接用&lt;code&gt;m_myInt-&amp;gt;Connect&lt;/code&gt;来把自己的处理函数连接上去。但是实际中往往是通过&lt;code&gt;myObj-&amp;gt;ConnectWithoutContext(&amp;quot;myInt&amp;quot;, MakeCallback(&amp;amp;mycallback))&lt;/code&gt;这样的方式。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; 
ObjectBase&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;TraceConnectWithoutContext (std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string name, &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; CallbackBase &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;cb)
{
  NS_LOG_FUNCTION (&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; name &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;cb);
  TypeId tid &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; GetInstanceTypeId ();
  Ptr&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; TraceSourceAccessor&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; accessor &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; tid.LookupTraceSourceByName (name);
  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (accessor &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
    {
      &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; false;
    }
  &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; ok &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; accessor&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;ConnectWithoutContext (&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;, cb);
  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; ok;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;Accessor&lt;/code&gt;我们之前已经讲过了，是一个在&lt;code&gt;GetTypeId&lt;/code&gt;里被调用并生成的一个类型，具体的&lt;code&gt;accessor-&amp;gt;ConnectWithoutContext&lt;/code&gt;在上面的&lt;code&gt;DoMakeTraceSourceAccessor&lt;/code&gt;里有定义，还是通过了&lt;code&gt;SOURCE T::*a&lt;/code&gt;这个类型得到了&lt;code&gt;TracedValue&lt;/code&gt;在类中的位置，调用了这个类型的&lt;code&gt;ConnectWithoutContext&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;至于&lt;code&gt;TracedCallback&lt;/code&gt;，理解起来就没什么难度了，在这个类型的&lt;code&gt;operator()&lt;/code&gt;里，注册进来的&lt;code&gt;Callback&lt;/code&gt;以此执行一遍即可。&lt;/p&gt;
&lt;p&gt;所以在运行是整个trace的过程是这样的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;m_myInt=1;会跑到&lt;code&gt;TracedValue&lt;/code&gt;的&lt;code&gt;operator=&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TracedValue::operator=&lt;/code&gt;调用了与&lt;code&gt;m_myInt&lt;/code&gt;相关联的&lt;code&gt;TracedCallback::operator()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TracedCallback::operator()&lt;/code&gt;以此调用事先注册好的&lt;code&gt;Callback&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;IidManager是一个数据库，TypeId是数据库的key，Attribute和TraceSource是数据库的两张表。每在&lt;code&gt;GetTypeId&lt;/code&gt;里&lt;code&gt;AddAttribute&lt;/code&gt;或者&lt;code&gt;AddTraceSouce&lt;/code&gt;一次就相当于给表里加一行记录，所有与&lt;code&gt;Attribute&lt;/code&gt;、&lt;code&gt;TraceSource&lt;/code&gt;相关的操作都会去表里找自己需要的信息。&lt;/li&gt;
&lt;li&gt;大量运用了模板和宏来&lt;em&gt;生成&lt;/em&gt;一些框架代码，比如Accessor。这也是代码难以理解之处的根本所在。熟悉一些模板的套路，比如CRTP（在object模型里用到）、PIMPL（callback里用到）；熟悉一些c++里的编程套路，比如在函数内部定义class（Accessor里用到），静态变量初始化（保证自定义Object可被注册时用到）；以及字面意义上的代码生成（宏，#与##），类型这个层次的代码生成（template，多个类型参数，traits），都是需要去细心体会的。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;后记&#34;&gt;后记&lt;/h1&gt;
&lt;p&gt;C++真难。&lt;/p&gt;
&lt;p&gt;这套代码看下来，也是让人惊叹C++真的是没有做不到，只有想不到。那些模板和宏生成代码的套路，基本上把能在编译期算的都在编译器搞定，能在初始化搞的全在初始化时完成，运行时跑得都是很难再简化的必要的逻辑。其实网络仿真程序也基本算一个&amp;quot;well-defined&amp;quot;的东西，有着明确的需求，又是开源项目，可以花心思把系统设计的如此巧妙。&lt;/p&gt;
&lt;p&gt;希望自己以后能有机会能从头参与类似项目的开发，而不是在反复无常的业务逻辑上消磨时光。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
