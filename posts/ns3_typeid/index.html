<!DOCTYPE html>


<html lang="zh-cn" data-theme="">
<head>
    
        
<meta charset="utf-8">
<meta name="HandheldFriendly" content="True">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="referrer" content="no-referrer-when-downgrade">

<title>TypeId in NS3 - 存留处</title>
<meta name="description" content="">

<link rel="icon" type="image/x-icon" href="https://ivkus.github.io/favicon.ico">
<link rel="apple-touch-icon-precomposed" href="https://ivkus.github.io/favicon.png">



    





    
    
    

    
        <link rel="stylesheet" href="https://ivkus.github.io/css/style.03fcbf2f5adfa317daeecc510bd9aa2cd268b14a385fc2498842fa5602e937f2.css" integrity="sha256-A/y/L1rfoxfa7sxRC9mqLNJosUo4X8JJiEL6VgLpN/I=">
    





<meta property="og:title" content="TypeId in NS3" />
<meta property="og:description" content="NS3作为一个网络仿真库，出于性能的考量选择了C&#43;&#43;。在写仿真程序时，不可避免的要对各种实体进行建模，自然C&#43;&#43;中的class成了唯一可选的方案。不加任何技巧的class的确可以满足对某些实体的建模，可是在仿真软件的编写中需要有足够的动态性，比如有这样一些需求：

动态的获知某个实体所具有的各类属性与属性的值
这个实体的状态变化后引发一系列的动作

这些都不是过分的需求，如果真的写过仿真程序的话肯定会非常渴求使用的软件能够提供实现这些需求的方法。要自己干巴巴的实现这些需求也不是不可以，比如可以提供一些查询接口来实现1；对于2的话，Qt的signal/slot或许可以实现。说到Qt了，其实QObject拥有了超越普通C&#43;&#43; class的能力，也都能满足上面指出的这些需求，但是其解决方案似乎有点重。
幸好，NS3通过TypeId可以很好的解决上面提出的各类需求。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ivkus.github.io/posts/ns3_typeid/" />
<meta property="article:published_time" content="2018-07-29T23:23:55+08:00" />
<meta property="article:modified_time" content="2018-07-29T23:23:55+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="TypeId in NS3"/>
<meta name="twitter:description" content="NS3作为一个网络仿真库，出于性能的考量选择了C&#43;&#43;。在写仿真程序时，不可避免的要对各种实体进行建模，自然C&#43;&#43;中的class成了唯一可选的方案。不加任何技巧的class的确可以满足对某些实体的建模，可是在仿真软件的编写中需要有足够的动态性，比如有这样一些需求：

动态的获知某个实体所具有的各类属性与属性的值
这个实体的状态变化后引发一系列的动作

这些都不是过分的需求，如果真的写过仿真程序的话肯定会非常渴求使用的软件能够提供实现这些需求的方法。要自己干巴巴的实现这些需求也不是不可以，比如可以提供一些查询接口来实现1；对于2的话，Qt的signal/slot或许可以实现。说到Qt了，其实QObject拥有了超越普通C&#43;&#43; class的能力，也都能满足上面指出的这些需求，但是其解决方案似乎有点重。
幸好，NS3通过TypeId可以很好的解决上面提出的各类需求。"/>











    
</head>
<body>
    <a class="skip-main" href="#main">Skip to main content</a>
    <div class="container">
        <header class="common-header"> 
            
                <div class="header-top">
    <h1 class="site-title">
        <a href="/">存留处</a>
    </h1>
    <ul class="social-icons">


</ul>

</div>

    <nav>
        
        
        <a class="" href="https://ivkus.github.io/posts/" title="Archive">Archive</a>
        
        <a class="" href="https://ivkus.github.io/tags/" title="">Tags</a>
        
        <a class="" href="https://ivkus.github.io/about/" title="">About</a>
        
    </nav>




            
        </header>
        <main id="main" tabindex="-1"> 
            
    
    
    <article class="post h-entry">
        <header class="post-header">
            <h1 class="p-name post-title">TypeId in NS3</h1>
        </header>
        <div class="content e-content">
            <p>NS3作为一个网络仿真库，出于性能的考量选择了C++。在写仿真程序时，不可避免的要对各种实体进行建模，自然C++中的class成了唯一可选的方案。不加任何技巧的class的确可以满足对某些实体的建模，可是在仿真软件的编写中需要有足够的动态性，比如有这样一些需求：</p>
<ol>
<li>动态的获知某个实体所具有的各类属性与属性的值</li>
<li>这个实体的状态变化后引发一系列的动作</li>
</ol>
<p>这些都不是过分的需求，如果真的写过仿真程序的话肯定会非常渴求使用的软件能够提供实现这些需求的方法。要自己干巴巴的实现这些需求也不是不可以，比如可以提供一些查询接口来实现1；对于2的话，Qt的signal/slot或许可以实现。说到Qt了，其实QObject拥有了超越普通C++ class的能力，也都能满足上面指出的这些需求，但是其解决方案似乎有点重。</p>
<p>幸好，NS3通过TypeId可以很好的解决上面提出的各类需求。</p>
<h1 id="typeid是什么"><code>TypeId</code>是什么</h1>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TypdId</span>
{
    <span style="color:#66d9ef">uint16_t</span> m_tid;
}
</code></pre></div><p>这就是TypdId，就是这么简单。似乎有些不可思议，但<code>TypdId</code>本身只是一个16bit的整型，之前提到的所有的复杂功能都是藏在<code>TypdId</code>背后的<code>IidManager</code>完成的，这个<code>m_tid</code>只是作为一个索引而存在。</p>
<p>TypdId提供了非常多的方法，比如说增加一个属性(<code>AddAttribute</code>)，增加一个TraceSource(<code>AddTraceSource</code>)，这些方法只是直接了当的将所需信息搜集起来转发给<code>IidManager</code>。可以看个例子：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">TypeId 
TypeId<span style="color:#f92672">::</span>AddAttribute (std<span style="color:#f92672">::</span>string name,
                      std<span style="color:#f92672">::</span>string help, 
                      <span style="color:#66d9ef">uint32_t</span> flags,
                      <span style="color:#66d9ef">const</span> AttributeValue <span style="color:#f92672">&amp;</span>initialValue,
                      Ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">const</span> AttributeAccessor<span style="color:#f92672">&gt;</span> accessor,
                      Ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">const</span> AttributeChecker<span style="color:#f92672">&gt;</span> checker,
                      SupportLevel supportLevel,
                      <span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>string <span style="color:#f92672">&amp;</span>supportMsg)
{
  NS_LOG_FUNCTION (<span style="color:#66d9ef">this</span> <span style="color:#f92672">&lt;&lt;</span> name <span style="color:#f92672">&lt;&lt;</span> help <span style="color:#f92672">&lt;&lt;</span> flags
                   <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">&amp;</span>initialValue <span style="color:#f92672">&lt;&lt;</span> accessor <span style="color:#f92672">&lt;&lt;</span> checker
                   <span style="color:#f92672">&lt;&lt;</span> supportLevel <span style="color:#f92672">&lt;&lt;</span> supportMsg);
  IidManager<span style="color:#f92672">::</span>Get ()<span style="color:#f92672">-&gt;</span>AddAttribute (m_tid, name, help, flags,
                                    initialValue.Copy (), accessor, checker,
                                    supportLevel, supportMsg);
  <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
}
</code></pre></div><p>基本上所有的<code>TypdId</code>的方法都是这个样子。所以解决问题的核心其实是<code>IidManager</code>。<code>IidManager</code>可认为是一个类型数据库，保存了与<code>TypdId</code>想关联的Attribute与TraceSource。具体的内部实现就太细节了，作为使用方是不需要也不应该去关注的。</p>
<h1 id="从使用角度看typdid">从使用角度看<code>TypdId</code></h1>
<p>正如在Qt中一样，想要使自己写的一个类拥有强大的能力，需要自己动手在类的声明中添加Q_OBJECT。在NS3设计的<code>TypeId</code>系统中，这个步骤是要给自己的class添加一个静态方法<code>static TypeId GetTypeId (void)</code>，然后在这个函数里返回一个<code>TypeId</code>。在这个过程，可以尽情的使用<code>TypeId</code>提供的各种方法来给本类加属性和TraceSource，唯一的限制就是这个返回的<code>TypeId</code>应该是处于<code>GetTypeId</code>里的静态变量，这是为了保证全局的唯一性。当然了，写C++的限制多了去了，这个规则应该归入这个NS3库的使用方法吧，不太值得吐槽。</p>
<p><code>TypeId</code>对于我们平时写程序的最大的帮助在于，它可以给自己的类添加Attribute和TraceSource。</p>
<p>Attribute可以代表该实体的一些属性，比如说一台PC的IP地址、一只猫的体重等。你可能会想，这个不就是一个Get函数的事儿么，值得专门搞这么一套复杂的系统么。其实还真值得：你会去写一个127.0.0.1还是2130706433？在NS3里，可以直接写127.0.0.1，这也得归功与这个Attribute系统。</p>
<p>TraceSource可类比Qt的Signal，在需要的时候调用这个Functor（想不到更好的名称了，不过写C++的应该都知道这个东西），连到这个TraceSource的其他函数（所谓的Slot）就会被自动调用。好处自不必多说，要知道Qt能得到广泛的认可，Signal/Slot功不可没，NS3里的TraceSource系统就是Signal/Slot的翻版。</p>
<p>还有一个使用限制就是，需要通过一个宏来告知系统我一个<code>TypeId</code>要注册：<code>NS_OBJECT_ENSURE_REGISTERED</code>。这个宏其实声明了一个静态类并同时声明了一个本文件内的静态实例。在这个静态类的构造函数中调用了我们定义的类的<code>GetTypeId</code>，这就实现了自定义<code>TypeId</code>的注册。</p>
<h1 id="attribute与tracesource">Attribute与TraceSource</h1>
<p>终于到重头戏了。其实这两部分的代码都切实的体现了C++罪恶的地方：模板与宏。一个新手要看懂这些代码要补充太多的东西了。说来惭愧，其实我自身也是一个新手，从开始接触这个库到现在能初步搞明白这样一个系统（真的只是大致初步明白），已经过去了3年多。这个系统的实现是模板里套宏、宏里套模板，看的时候需要时刻注意这段代码是宏生成的代码还是用了模板。</p>
<h2 id="attribute">Attribute</h2>
<p>前面提到了我们可以用127.0.0.1来代表ip的那32个bit，这就是Attribute系统的神奇所在。在这个例子里，127.0.0.1其实是一个字符串，Attribute系统可以把字符串转化为任何一种类型（可以是自定义类型）。</p>
<p>就单纯的以这个地址类型来解释好了。我们的程序中需要使用IP地址，其最合适的存储方式其实是一个int，但IP地址最适合人类的表述方式其实是点分表示，我们自然也想在使用的时候用这种方式。那这个应该怎么做？</p>
<p>首先先不管人怎么读写的问题，先考虑程序中的这个属性的使用方式。作为一个Ipv4的值，肯定有一些相关联的方法，比如说是否为广播地址、是否为多播地址、是否为本地地址之类类的。这些可以以用成员函数的方式实现，既然这样，那就尽情的实现吧！不需要考虑怎么集成到Attribute系统中去。同理，这个类里面有什么字段，想要什么字段就尽情的加。想必你也看出来了，我们在实现一个Attribute的时候，其实根本不需要考虑什么集成的问题。</p>
<p>能够用ns3的方式来给一个对象设置属性的这个能力依赖与3个基本的组件</p>
<ol>
<li><code>AttributeValue</code></li>
<li><code>AttributeAccessor</code></li>
<li><code>AttributeChecker</code></li>
</ol>
<p>首先看看什么是ns3的方式为一个对象设置属性，看一下官方manual里的例子</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">Ptr<span style="color:#f92672">&lt;</span>ConfigExample<span style="color:#f92672">&gt;</span> a2_obj <span style="color:#f92672">=</span> CreateObject<span style="color:#f92672">&lt;</span>ConfigExample<span style="color:#f92672">&gt;</span> ();
a2_obj<span style="color:#f92672">-&gt;</span>SetAttribute (<span style="color:#e6db74">&#34;TestInt16&#34;</span>, IntegerValue (<span style="color:#f92672">-</span><span style="color:#ae81ff">3</span>));
IntegerValue iv;
a2_obj<span style="color:#f92672">-&gt;</span>GetAttribute (<span style="color:#e6db74">&#34;TestInt16&#34;</span>, iv);
</code></pre></div><p>第一行创建了新的对象<code>ConfigExample</code>，并存在指针<code>a2_obj</code>里。第二行就是所谓的ns3的方式设置属性，依赖于一个方法<code>SetAttriute</code>。这个方法属于<code>ObjectBase</code>，所有能用<code>Ptr</code>指向的对象都是<code>objectBase</code>的子类。所以说，在调用<code>SetAttribute</code>时，除去C++的语法糖，这句话完整的形式是这样的：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">SetAttribute (a2_obj, <span style="color:#e6db74">&#34;TestInt16&#34;</span>, IntegerValue (<span style="color:#f92672">-</span><span style="color:#ae81ff">3</span>));
</code></pre></div><p>好了，我们跳进去看看实现</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">void</span>
ObjectBase<span style="color:#f92672">::</span>SetAttribute (std<span style="color:#f92672">::</span>string name, <span style="color:#66d9ef">const</span> AttributeValue <span style="color:#f92672">&amp;</span>value)
{
  NS_LOG_FUNCTION (<span style="color:#66d9ef">this</span> <span style="color:#f92672">&lt;&lt;</span> name <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">&amp;</span>value);
  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">TypeId</span><span style="color:#f92672">::</span>AttributeInformation info;
  TypeId tid <span style="color:#f92672">=</span> GetInstanceTypeId ();
  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>tid.LookupAttributeByName (name, <span style="color:#f92672">&amp;</span>info))
    {
      NS_FATAL_ERROR (<span style="color:#e6db74">&#34;Attribute name=&#34;</span><span style="color:#f92672">&lt;&lt;</span>name<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34; does not exist for this object: tid=&#34;</span><span style="color:#f92672">&lt;&lt;</span>tid.GetName ());
    }
  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>(info.flags <span style="color:#f92672">&amp;</span> TypeId<span style="color:#f92672">::</span>ATTR_SET) <span style="color:#f92672">||</span>
      <span style="color:#f92672">!</span>info.accessor<span style="color:#f92672">-&gt;</span>HasSetter ())
    {
      NS_FATAL_ERROR (<span style="color:#e6db74">&#34;Attribute name=&#34;</span><span style="color:#f92672">&lt;&lt;</span>name<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34; is not settable for this object: tid=&#34;</span><span style="color:#f92672">&lt;&lt;</span>tid.GetName ());
    }
  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>DoSet (info.accessor, info.checker, value))
    {
      NS_FATAL_ERROR (<span style="color:#e6db74">&#34;Attribute name=&#34;</span><span style="color:#f92672">&lt;&lt;</span>name<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34; could not be set for this object: tid=&#34;</span><span style="color:#f92672">&lt;&lt;</span>tid.GetName ());
    }
}
</code></pre></div><p>这个方法是对象自己身上的方法，所以要记住<code>this</code>这时候指向的是谁：这里就是<code>a2_obj</code>。这个方法也很直白</p>
<ol>
<li>首先能通过<code>GetInstanceTypdId()</code>拿到真正的、<code>ConfigExample</code>的<code>TypeId</code></li>
<li>拿到<code>AttributeInformation</code>，就有了<code>accessor</code>、<code>checker</code>，还有作为参数传进来的值<code>value</code>。</li>
<li><code>DoSet</code>做了实际的设置工作</li>
</ol>
<p>再看看<code>DoSet</code>：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">bool</span>
ObjectBase<span style="color:#f92672">::</span>DoSet (Ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">const</span> AttributeAccessor<span style="color:#f92672">&gt;</span> accessor, 
                   Ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">const</span> AttributeChecker<span style="color:#f92672">&gt;</span> checker,
                   <span style="color:#66d9ef">const</span> AttributeValue <span style="color:#f92672">&amp;</span>value)
{
  NS_LOG_FUNCTION (<span style="color:#66d9ef">this</span> <span style="color:#f92672">&lt;&lt;</span> accessor <span style="color:#f92672">&lt;&lt;</span> checker <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">&amp;</span>value);
  Ptr<span style="color:#f92672">&lt;</span>AttributeValue<span style="color:#f92672">&gt;</span> v <span style="color:#f92672">=</span> checker<span style="color:#f92672">-&gt;</span>CreateValidValue (value);
  <span style="color:#66d9ef">if</span> (v <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
    {
      <span style="color:#66d9ef">return</span> false;
    }
  <span style="color:#66d9ef">bool</span> ok <span style="color:#f92672">=</span> accessor<span style="color:#f92672">-&gt;</span>Set (<span style="color:#66d9ef">this</span>, <span style="color:#f92672">*</span>v);
  <span style="color:#66d9ef">return</span> ok;
}
</code></pre></div><p>检查什么的就不说了，最让人关心的是这个方法<code>accessor-&gt;Set (this, *v)</code>。这个方法是怎么定义的，是哪里来的？这下欢迎进入模板与宏的世界。</p>
<h3 id="attributeaccessor"><code>AttributeAccessor</code></h3>
<p>答案是这个这个方法是属于<code>accessor</code>的，而<code>accessor</code>的定义是在注册TypeId的时候生成的。RTFSC：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ConfigExample</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Object
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
  <span style="color:#66d9ef">static</span> TypeId GetTypeId (<span style="color:#66d9ef">void</span>) {
    <span style="color:#66d9ef">static</span> TypeId tid <span style="color:#f92672">=</span> TypeId (<span style="color:#e6db74">&#34;ns3::A&#34;</span>)
      .SetParent<span style="color:#f92672">&lt;</span>Object<span style="color:#f92672">&gt;</span> ()
      .AddAttribute (<span style="color:#e6db74">&#34;TestInt16&#34;</span>, <span style="color:#e6db74">&#34;help text&#34;</span>,
                     IntegerValue (<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>),
                     MakeIntegerAccessor (<span style="color:#f92672">&amp;</span>A<span style="color:#f92672">::</span>m_int16),
                     MakeIntegerChecker<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int16_t</span><span style="color:#f92672">&gt;</span> ())
      ;
      <span style="color:#66d9ef">return</span> tid;
    }
  <span style="color:#66d9ef">int16_t</span> m_int16;
};

NS_OBJECT_ENSURE_REGISTERED (ConfigExample);
</code></pre></div><p>看到那句<code>MakeIntegerAccessor (&amp;A::m_int16)</code>了么？搞懂了这个，其实就能搞懂ns3的套路了，再看其他的机制也就顺风顺水了。我们慢慢来，一步一步来，保证每一步都有始有终，不会出现跳跃的现象。这个过程稍微有点冗长，可以去拿包零食边吃边看了。</p>
<p><code>MakeIntegerAccessor</code>是可调用的一个“东西”。回想一下C++可调用的东西有哪些？1. 函数，2. Functor，就是实现了自定义operator()的一个class的实例。3.实例化一个类型看起来也像是函数调用。我用的Eclipse，f3跳转到定义，等我过去的时候傻眼了：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">ATTRIBUTE_ACCESSOR_DEFINE (Integer);
</code></pre></div><p>好家伙，看来要展开这个看看了，ctrl+=让它现形：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T1<span style="color:#f92672">&gt;</span>                                                \
Ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">const</span> AttributeAccessor<span style="color:#f92672">&gt;</span> MakeIntegerAccessor (T1 a1)              \
{                                                                     \
  <span style="color:#66d9ef">return</span> MakeAccessorHelper<span style="color:#f92672">&lt;</span>IntegerValue<span style="color:#f92672">&gt;</span> (a1);                       \
}                                                                     \
<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T1, <span style="color:#66d9ef">typename</span> T2<span style="color:#f92672">&gt;</span>                                   \
Ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">const</span> AttributeAccessor<span style="color:#f92672">&gt;</span> MakeIntegerAccessor (T1 a1, T2 a2)       \
{                                                                     \
  <span style="color:#66d9ef">return</span> MakeAccessorHelper<span style="color:#f92672">&lt;</span>IntegerValue<span style="color:#f92672">&gt;</span> (a1, a2);                   \
}
</code></pre></div><p>这展开了2个函数，到这时可以确定，<code>MakeIntegerAccessor</code>是一个函数，而且我们调用的是只有一个入参的那个函数，这个函数返回了一个<code>AttributeAccessor</code>的智能指针。具体的展开过程就不细讲了，也没有讲的必要，看看<code>ATTRIBUTE_ACCESSOR_DEFINE</code>的定义就明白了。现在需要关心的是我们现在调用的函数里有个<code>T1</code>，要搞明白这个<code>T1</code>的类型是什么。</p>
<p>重新回头看看<code>MakeIntegerAccessor (&amp;A::m_int16)</code>，这里的<code>T1</code>就是<code>&amp;A::m_int16</code>的类型。先就此打住，这个结论先记下来。我们继续追下去，这下应该看真正的实现<code>MakeAccessorHelper&lt;IntegerValue&gt; (a1)</code>：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">// 第一种实现
</span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> V, <span style="color:#66d9ef">typename</span> T, <span style="color:#66d9ef">typename</span> U<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">inline</span>
Ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">const</span> AttributeAccessor<span style="color:#f92672">&gt;</span>
DoMakeAccessorHelperOne (U T<span style="color:#f92672">::*</span>memberVariable)

<span style="color:#75715e">// 第二种实现
</span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> V, <span style="color:#66d9ef">typename</span> T, <span style="color:#66d9ef">typename</span> U<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">inline</span>
Ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">const</span> AttributeAccessor<span style="color:#f92672">&gt;</span>
DoMakeAccessorHelperOne (U (T<span style="color:#f92672">::*</span>getter)(<span style="color:#66d9ef">void</span>) <span style="color:#66d9ef">const</span>)

<span style="color:#75715e">// 第三种实现
</span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> V, <span style="color:#66d9ef">typename</span> T, <span style="color:#66d9ef">typename</span> U<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">inline</span>
Ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">const</span> AttributeAccessor<span style="color:#f92672">&gt;</span>
DoMakeAccessorHelperOne (<span style="color:#66d9ef">void</span> (T<span style="color:#f92672">::*</span>setter)(U))
</code></pre></div><p>结果就是匹配到了第一种实现。
其实我曾经很多次追到了这里，却没看懂这里的类型到底是什么意思。也不知道什么时候忽然就明白了。<code>A::m_int16</code>对应于<code>U T::*</code>，是个正常人第一眼看上去绝对不会明白这到底是怎么联系在一起的，我也是正常人，所以我现在也不明白这种怪异的语法到底是谁第一次使用的。<code>T</code>对应于<code>A</code>，那么<code>U</code>应该是对应于<code>m_int16</code>。这个类型能代表一个类里的一个成员变量的类型，<code>T</code>表明了它是一个类的成员变量，<code>U</code>表明了这个变量的类型是<code>uint16_t</code>，现在就只能这么死记了，要想真正搞明白我觉得应该去翻一下编译器里前端到底是怎么解析这个鬼畜般的语法的，先就这么囫囵吞枣吧！对于另外的两个反而更好懂一点，那个类型和平时用的函数指针类型声明挺像的，反而不用多说。一个是<code>getter</code>，说明这个attribute只提供了获取的接口；一个是setter，说明这个<code>attribute</code>只能设置不能获取。当然了，这是站在ns3的使用方式上说的，直接强行用c++的方式赋值不在我们的讨论范围之内。</p>
<p>这3个函数都返回了一个指向<code>AttributeAccessor</code>的指针。现在来看看实现吧！</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">Ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">const</span> AttributeAccessor<span style="color:#f92672">&gt;</span>
DoMakeAccessorHelperOne (U T<span style="color:#f92672">::*</span>memberVariable)
{
  <span style="color:#75715e">/* AttributeAcessor implementation for a class member variable. */</span>
  <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MemberVariable</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> AccessorHelper<span style="color:#f92672">&lt;</span>T,V<span style="color:#f92672">&gt;</span>
  {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#75715e">/*
</span><span style="color:#75715e">     * Construct from a class data member address.
</span><span style="color:#75715e">     * \param [in] memberVariable The class data member address.
</span><span style="color:#75715e">     */</span>
    MemberVariable (U T<span style="color:#f92672">::*</span>memberVariable)
      <span style="color:#f92672">:</span> AccessorHelper<span style="color:#f92672">&lt;</span>T,V<span style="color:#f92672">&gt;</span> (),
        m_memberVariable (memberVariable)
    {}
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">bool</span> DoSet (T <span style="color:#f92672">*</span>object, <span style="color:#66d9ef">const</span> V <span style="color:#f92672">*</span>v) <span style="color:#66d9ef">const</span> {
      <span style="color:#66d9ef">typename</span> AccessorTrait<span style="color:#f92672">&lt;</span>U<span style="color:#f92672">&gt;::</span>Result tmp;
      <span style="color:#66d9ef">bool</span> ok <span style="color:#f92672">=</span> v<span style="color:#f92672">-&gt;</span>GetAccessor (tmp);
      <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>ok)
        {
          <span style="color:#66d9ef">return</span> false;
        }
      (object<span style="color:#f92672">-&gt;*</span>m_memberVariable) <span style="color:#f92672">=</span> tmp;
      <span style="color:#66d9ef">return</span> true;
    }
    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">DoGet</span> (<span style="color:#66d9ef">const</span> T <span style="color:#f92672">*</span>object, V <span style="color:#f92672">*</span>v) <span style="color:#66d9ef">const</span> {
      v<span style="color:#f92672">-&gt;</span>Set (object<span style="color:#f92672">-&gt;*</span>m_memberVariable);
      <span style="color:#66d9ef">return</span> true;
    }
    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">HasGetter</span> (<span style="color:#66d9ef">void</span>) <span style="color:#66d9ef">const</span> {
      <span style="color:#66d9ef">return</span> true;
    }
    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">HasSetter</span> (<span style="color:#66d9ef">void</span>) <span style="color:#66d9ef">const</span> {
      <span style="color:#66d9ef">return</span> true;
    }

    U T<span style="color:#f92672">::*</span>m_memberVariable;  <span style="color:#75715e">// Address of the class data member.
</span><span style="color:#75715e"></span>  };
  <span style="color:#66d9ef">return</span> Ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">const</span> AttributeAccessor<span style="color:#f92672">&gt;</span> (<span style="color:#66d9ef">new</span> MemberVariable (memberVariable), false);
}
</code></pre></div><p>照样很鬼畜。这是在函数里定义了一个类，并且返回了指向这个类的只能指针。这个类继承自<code>AccessorHelper</code>，而<code>AccessorHelper</code>又继承自<code>AttributeAccessor</code>。所以将其作为<code>AttributeAccessor</code>的子类返回也说得过去。</p>
<p>至于为什么要继承这么多？我现在的理解是这样的</p>
<ol>
<li><code>AttributeAccessor</code>只是一个纯虚接口，它只定义了作为Accessor应当具有的接口。在Java里的话，估计这就是个Interface。</li>
<li><code>AccessorHelper</code>提供了<code>Set</code>和<code>Get</code>的默认实现，把一些可变的部分留给了它的子类来实现，这些可变的部分是<code>DoSet</code>和<code>DoGet</code>。所以在<code>MemberVariable</code>要实现<code>DoSet</code>和<code>DoGet</code>。这应该是某种设计模式，看看那本书就能找到了。</li>
</ol>
<p>到现在为止，我们知道可以造出来一个<code>AttributeAccessor</code>，并把指向这个<code>AttributeAccessor</code>的指针存在了我们的<code>IidManager</code>的数据库中。以后想要拿出来这个<code>AttributeAccessor</code>，就要手拿<code>TypeId</code>去找<code>IidManager</code>去要，而且要到的也是一个指针，这个指针指向了在<code>return Ptr&lt;const AttributeAccessor&gt; (new MemberVariable (memberVariable), false);</code>这句话里的那个new出来的地址。</p>
<p>总结一下，一个类型的<code>AttributeAccessor</code>只有一个，就是那个new出来的地方。程序其他地方都是拿指针去访问的。在那块地址存的东西只有两样（只考虑我们现在这个membervariable类型的accessor）</p>
<ol>
<li><code>U T::*m_memberVariable</code>的值，这个值代表了这个变量在拥有<code>TypeId</code>那个类里的偏移量</li>
<li>一个虚表指针。因为是有virtual函数，所以这个<code>AttributeAccessor</code>的实例是有虚表指针的，这个虚表里就是真正的、对应类型的函数实现。</li>
</ol>
<p>回头看看那个<code>DoSet</code>，里面那个accessor到底是什么应该已经清楚了。那个个accessor的<code>Set</code>方法在哪儿定义的？答案是<code>AccessorHelper</code>。我直接把结论公开了，但是你现在应该停下来去看看具体的实现。<code>AttributeAccessor</code>-&gt;<code>AccessorHelper</code>-&gt;<code>DoMakeAccessorHelperOne()里的MemberVariable</code>这是一条继承链，到了最下一层的时候所有的方法都已经定义，只是在不同的层次提供了不同的实现。</p>
<p>假设你已经搞明白<code>Accessor</code>的继承链条了，也明白这个<code>Accessor</code>到底支持什么操作，我们就进入了真正执行<code>Set</code>的地方：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">// DoMakeAccessorHelperOne()里的MemberVariable的方法
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">DoSet</span> (T <span style="color:#f92672">*</span>object, <span style="color:#66d9ef">const</span> V <span style="color:#f92672">*</span>v) <span style="color:#66d9ef">const</span> {
  <span style="color:#66d9ef">typename</span> AccessorTrait<span style="color:#f92672">&lt;</span>U<span style="color:#f92672">&gt;::</span>Result tmp;
  <span style="color:#66d9ef">bool</span> ok <span style="color:#f92672">=</span> v<span style="color:#f92672">-&gt;</span>GetAccessor (tmp);
  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>ok)
    {
      <span style="color:#66d9ef">return</span> false;
    }
  (object<span style="color:#f92672">-&gt;*</span>m_memberVariable) <span style="color:#f92672">=</span> tmp;
  <span style="color:#66d9ef">return</span> true;
}
</code></pre></div><p>这里的<code>V *v</code>就是<code>myObj-&gt;SetAttribute (&quot;MyIntAttribute&quot;, IntegerValue(3));</code>里的<code>IntegerValue(3)</code>。要是没看懂，就去翻代码。这个结论是必须要搞懂的，不然就没有进行下去的必要了。</p>
<p>其实<code>Accessor</code>的世界已经探索的差不多了，为了真正搞明白这个函数做了什么，我们先转向看看<code>AttributeValue</code>。</p>
<h3 id="attributevalue"><code>AttributeValue</code></h3>
<p>NS3的套路是什么？用宏和模板做代码生成。这个套路在<code>AttributeValue</code>里也是一样的。自定义了一个<code>AttributeValue</code>需要写一个宏，这个宏帮助我们做了大部分的事情。拿那个<code>IntegerValue</code>说事儿:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">ATTRIBUTE_VALUE_DEFINE_WITH_NAME (<span style="color:#66d9ef">uint64_t</span>, Uinteger);
<span style="color:#75715e">// 在头文件里写这个宏，能够展开为如下的定义
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">UintegerValue</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> AttributeValue                             \
  {                                                                     \
  <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>                                                               \
    UintegerValue ();                                                   \
    UintegerValue (<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">&amp;</span>value);                              \
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Set</span> (<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">&amp;</span>value);                                   \
    <span style="color:#66d9ef">uint64_t</span> <span style="color:#a6e22e">Get</span> (<span style="color:#66d9ef">void</span>) <span style="color:#66d9ef">const</span>;                                          \
    <span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>                                               \
      <span style="color:#66d9ef">bool</span> GetAccessor (T <span style="color:#f92672">&amp;</span>value) <span style="color:#66d9ef">const</span> {                               \
      value <span style="color:#f92672">=</span> T (m_value);                                              \
      <span style="color:#66d9ef">return</span> true;                                                      \
    }                                                                   \
    <span style="color:#66d9ef">virtual</span> Ptr<span style="color:#f92672">&lt;</span>AttributeValue<span style="color:#f92672">&gt;</span> Copy (<span style="color:#66d9ef">void</span>) <span style="color:#66d9ef">const</span>;                      \
    <span style="color:#66d9ef">virtual</span> std<span style="color:#f92672">::</span>string                                                 \
      SerializeToString (Ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">const</span> AttributeChecker<span style="color:#f92672">&gt;</span> checker) <span style="color:#66d9ef">const</span>;    \
    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">bool</span>                                                        \
      DeserializeFromString (std<span style="color:#f92672">::</span>string value,                         \
                             Ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">const</span> AttributeChecker<span style="color:#f92672">&gt;</span> checker);      \
  <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>                                                              \
    <span style="color:#66d9ef">uint64_t</span> m_value;                                                   \
  }

<span style="color:#75715e">// 上述定义的实现仰赖于对于cc文件里的实现，也是用宏
</span><span style="color:#75715e"></span>ATTRIBUTE_VALUE_IMPLEMENT_WITH_NAME (<span style="color:#66d9ef">uint64_t</span>,Uinteger);

<span style="color:#75715e">// 展开后是这样的
</span><span style="color:#75715e"></span>UintegerValue<span style="color:#f92672">::</span>UintegerValue ()                                         \
    <span style="color:#f92672">:</span> m_value () {}                                                     \
  UintegerValue<span style="color:#f92672">::</span>UintegerValue (<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">&amp;</span>value)                  \
    <span style="color:#f92672">:</span> m_value (value) {}                                                \
  <span style="color:#66d9ef">void</span> UintegerValue<span style="color:#f92672">::</span>Set (<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">uint64_t</span> <span style="color:#f92672">&amp;</span>v) {                         \
    m_value <span style="color:#f92672">=</span> v;                                                        \
  }                                                                     \
  <span style="color:#66d9ef">uint64_t</span>  UintegerValue<span style="color:#f92672">::</span>Get (<span style="color:#66d9ef">void</span>) <span style="color:#66d9ef">const</span> {                           \
    <span style="color:#66d9ef">return</span> m_value;                                                     \
  }                                                                     \
  Ptr<span style="color:#f92672">&lt;</span>AttributeValue<span style="color:#f92672">&gt;</span>                                                   \
  UintegerValue<span style="color:#f92672">::</span>Copy (<span style="color:#66d9ef">void</span>) <span style="color:#66d9ef">const</span> {                                    \
    <span style="color:#66d9ef">return</span> ns3<span style="color:#f92672">::</span>Create<span style="color:#f92672">&lt;</span>UintegerValue<span style="color:#f92672">&gt;</span> (<span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>);                          \
  }                                                                     \
  std<span style="color:#f92672">::</span>string UintegerValue<span style="color:#f92672">::</span>SerializeToString                          \
    (Ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">const</span> AttributeChecker<span style="color:#f92672">&gt;</span> checker) <span style="color:#66d9ef">const</span> {                       \
      std<span style="color:#f92672">::</span>ostringstream oss;                                           \
      oss <span style="color:#f92672">&lt;&lt;</span> m_value;                                                   \
      <span style="color:#66d9ef">return</span> oss.str ();                                                \
  }                                                                     \
  <span style="color:#66d9ef">bool</span> UintegerValue<span style="color:#f92672">::</span>DeserializeFromString                             \
    (std<span style="color:#f92672">::</span>string value, Ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">const</span> AttributeChecker<span style="color:#f92672">&gt;</span> checker) {          \
      std<span style="color:#f92672">::</span>istringstream iss;                                           \
      iss.str (value);                                                  \
      iss <span style="color:#f92672">&gt;&gt;</span> m_value;                                                   \
      <span style="color:#66d9ef">do</span> {                                                                 \
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>(iss.eof ()))                                                          \
      {                                                                \
        std<span style="color:#f92672">::</span>cerr <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;aborted. cond=</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;!(iss.eof ())&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">, &#34;</span>;           \
        <span style="color:#66d9ef">do</span>                                                    \
    {                                                   \
      std<span style="color:#f92672">::</span>cerr <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;msg=</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Attribute value &#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">&lt;&lt;</span> value <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">&#34;</span>  \
                           <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; is not properly formatted&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">, &#34;</span>;           \
      <span style="color:#66d9ef">do</span>                                                      \
    {                                                     \
      std<span style="color:#f92672">::</span>cerr <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;file=&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;D:</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">Code</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">ns-allinone-3.28</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">ns-3.28</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">src</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">core</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">model</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">uinteger.cc&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;, line=&#34;</span> <span style="color:#f92672">&lt;&lt;</span>    \
        <span style="color:#ae81ff">35</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;                            \
      <span style="color:#f92672">::</span>ns3<span style="color:#f92672">::</span>FatalImpl<span style="color:#f92672">::</span>FlushStreams ();                  \
      <span style="color:#66d9ef">if</span> (true) std<span style="color:#f92672">::</span>terminate ();                       \
    }                                                     \
  <span style="color:#66d9ef">while</span> (false);               \
    }                                                   \
  <span style="color:#66d9ef">while</span> (false);                                          \
      }                                                                \
  } <span style="color:#66d9ef">while</span> (false);            \
      <span style="color:#66d9ef">return</span> <span style="color:#f92672">!</span>iss.bad () <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>iss.fail ();                               \
  }
</code></pre></div><p>具体的展开过程感兴趣的可以去追一下，要是没有IDE的帮助，要展开一个这么复杂的宏也还是需要一点时间的。结合之前accessor的内容(<code>v-&gt;GetAccessor</code>)，这个函数就定义在了这里（头文件里作为模板类成员函数实现了）。</p>
<p>值得一看的倒是那两个<code>SerializeToString</code>和<code>DeserializerFromString</code>。这两个函数完成了字符串到实际定义类型的转换，里面用到了<code>&lt;&lt;</code>的重载，所以这也是为什么在自定义属性的时候要去实现全局<code>operator&lt;&lt;</code>的原因了。通过这两个函数，我们就可以用一个字面意义上的127.0.0.1去设置一个IP，而非2130706433。其实这个系统在解析string的时候出了一点小bug被我发现了，也算是对开源的一点点小贡献吧!(<a href="https://www.nsnam.org/bugzilla/show_bug.cgi?id=2447">https://www.nsnam.org/bugzilla/show_bug.cgi?id=2447</a>) 这个bug在ns3.25里提出来，之后应该是修好了。</p>
<p>还剩一个<code>AttributeChecker</code>，但这个好像不影响对系统的理解，就不去看啦！想必搞明白套路之后，要看懂也不是什么难事儿啦！</p>
<h2 id="tracesource"><code>TraceSource</code></h2>
<h3 id="callback杂谈"><code>Callback</code>杂谈</h3>
<p>说起TraceSource，那么<code>Callback</code>就是绕不过去的坎。可以作为一个<code>TraceSource</code>的属性关联一个<code>TracedCallback</code>类型，用于通知自身值的改变。<code>TracedCallback</code>只是一个<code>Callback</code>的容器，里面有一个<code>std::list&lt;Callback&gt;</code>用于存放连接到该<code>TraceSource</code>的函数。一个<code>TraceSource</code>可以连接多次，每次它被<code>Connect</code>一次，就会往这个list里填一个元素。当然，这个元素就是一个<code>Callback</code>。</p>
<p><code>Callback</code>类本身只是提供了创建的接口于调用接口。调用接口就是对各个<code>operator()</code>的重载，最多有9个参数，也因此有9个<code>operator()</code>。这种情况在<code>c++11</code>之后应该会有更好的写法，只是我并不知道怎么写罢了。<code>Callback</code>继承自<code>CallbackBase</code>，这里存放了真正的指向实现(<code>CallbackImplBase</code>)的指针。</p>
<p>怎么<code>CallbaciImpl</code>还有继承？从<code>Callback</code>开始已经跳转两次了还没见到真正的实现，其实这也不远了，<code>CallbackImplBase</code>说到底就是一个<code>Interface</code>一样的东西，对<code>CallbackImpl</code>做了一些限定，这样继承了<code>CallbackImpl</code>的子类就能以比较一致的方法去操作。其实<code>CallbackImplBase</code>-&gt;<code>CallbackImpl</code>-&gt;各种具体的<code>CallbackImpl</code>弄这么复杂也是无奈之举。抽出来中间的<code>CallbackImpl</code>是为了实现多输入参数类型的<code>operator()</code>的重载，考虑到这个库的编写时间，那时候的c++模板编程好像没有c++11之后的那么完善，没有可变长类型参数，这样做也是无可厚非。我想如果用最新的<code>c++11</code>之后的标准来写，这个<code>Callback</code>可能就不会这么难以理解了，似乎可以直接采用<code>std::function</code>或者只是做一些小的改动就可以了。不管怎样，到了<code>CallbackImpl</code>这个层级时，单单<code>CallbackImpl</code>这个名字就已经可以支撑多达9个入参的<code>operator()</code>了，再下面层级的类就可以方便的享用这种便利，这也是为什么<code>MemPtrCallbackImpl</code>、<code>FunctorCallbackImpl</code>等子类可以在一个class里就重载多次<code>operator()</code>同时还能做类型检查的原因了。</p>
<h3 id="tracedvalue追踪"><code>TracedValue</code>追踪</h3>
<p>先来看看在<code>TypeId</code>里怎么使用<code>TraceSource</code>吧！我随便从代码里摘了一条出来</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">.AddTraceSource (<span style="color:#e6db74">&#34;Tx&#34;</span>, <span style="color:#e6db74">&#34;A new packet is created and is sent&#34;</span>,
                MakeTraceSourceAccessor (<span style="color:#f92672">&amp;</span>BulkSendApplication<span style="color:#f92672">::</span>m_txTrace),
                <span style="color:#e6db74">&#34;ns3::Packet::TracedCallback&#34;</span>)
</code></pre></div><p>又看到了熟悉的<code>Accessor</code>，这个<code>Accessor</code>为的就是能拿到类里的一个成员变量。所幸对于<code>TraceSource</code>来说，只存在访问<code>Get</code>而不存在设置<code>Set</code>，这个<code>Accessor</code>相比起<code>AttributeAccessor</code>来说要简单一些。追到代码里看到的还是熟悉的的套路：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
Ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">const</span> TraceSourceAccessor<span style="color:#f92672">&gt;</span> MakeTraceSourceAccessor (T a)
{
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">DoMakeTraceSourceAccessor</span> (a);
}
<span style="color:#75715e">// DoMakeTraceSourceAccessor的实现
</span><span style="color:#75715e">// 在函数内部定义新的类，这个类实现了TraceSourceAccessor的接口
</span><span style="color:#75715e">// 因为`TraceSource`只有一种类型，这种类型就是
</span><span style="color:#75715e">// “类内部的成员变量”
</span><span style="color:#75715e">// 所以可以看到函数的签名就只有一种
</span><span style="color:#75715e">// SOURCE T::a
</span><span style="color:#75715e">// sigh...又是这个鬼畜的标记
</span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T, <span style="color:#66d9ef">typename</span> SOURCE<span style="color:#f92672">&gt;</span>
Ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">const</span> TraceSourceAccessor<span style="color:#f92672">&gt;</span> 
DoMakeTraceSourceAccessor (SOURCE T<span style="color:#f92672">::*</span>a)
{
  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Accessor</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> TraceSourceAccessor
  {
    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">ConnectWithoutContext</span> (ObjectBase <span style="color:#f92672">*</span>obj, <span style="color:#66d9ef">const</span> CallbackBase <span style="color:#f92672">&amp;</span>cb) <span style="color:#66d9ef">const</span> {
      T <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> <span style="color:#66d9ef">dynamic_cast</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">*&gt;</span> (obj);
      <span style="color:#66d9ef">if</span> (p <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
        {
          <span style="color:#66d9ef">return</span> false;
        }
      (p<span style="color:#f92672">-&gt;*</span>m_source).ConnectWithoutContext (cb);
      <span style="color:#66d9ef">return</span> true;
    }
    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">Connect</span> (ObjectBase <span style="color:#f92672">*</span>obj, std<span style="color:#f92672">::</span>string context, <span style="color:#66d9ef">const</span> CallbackBase <span style="color:#f92672">&amp;</span>cb) <span style="color:#66d9ef">const</span> {
      T <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> <span style="color:#66d9ef">dynamic_cast</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">*&gt;</span> (obj);
      <span style="color:#66d9ef">if</span> (p <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
        {
          <span style="color:#66d9ef">return</span> false;
        }
      (p<span style="color:#f92672">-&gt;*</span>m_source).Connect (cb, context);
      <span style="color:#66d9ef">return</span> true;
    }
    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">DisconnectWithoutContext</span> (ObjectBase <span style="color:#f92672">*</span>obj, <span style="color:#66d9ef">const</span> CallbackBase <span style="color:#f92672">&amp;</span>cb) <span style="color:#66d9ef">const</span> {
      T <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> <span style="color:#66d9ef">dynamic_cast</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">*&gt;</span> (obj);
      <span style="color:#66d9ef">if</span> (p <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
        {
          <span style="color:#66d9ef">return</span> false;
        }
      (p<span style="color:#f92672">-&gt;*</span>m_source).DisconnectWithoutContext (cb);
      <span style="color:#66d9ef">return</span> true;
    }
    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">Disconnect</span> (ObjectBase <span style="color:#f92672">*</span>obj, std<span style="color:#f92672">::</span>string context, <span style="color:#66d9ef">const</span> CallbackBase <span style="color:#f92672">&amp;</span>cb) <span style="color:#66d9ef">const</span> {
      T <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> <span style="color:#66d9ef">dynamic_cast</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">*&gt;</span> (obj);
      <span style="color:#66d9ef">if</span> (p <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
        {
          <span style="color:#66d9ef">return</span> false;
        }
      (p<span style="color:#f92672">-&gt;*</span>m_source).Disconnect (cb, context);
      <span style="color:#66d9ef">return</span> true;
    }
    SOURCE T<span style="color:#f92672">::*</span>m_source;
  } <span style="color:#f92672">*</span>accessor <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Accessor ();
  accessor<span style="color:#f92672">-&gt;</span>m_source <span style="color:#f92672">=</span> a;
  <span style="color:#66d9ef">return</span> Ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">const</span> TraceSourceAccessor<span style="color:#f92672">&gt;</span> (accessor, false);
}
</code></pre></div><p><code>TraceSource</code>存在的理由就是要触发其他的逻辑的，因此要提供挂接其他逻辑的方法，即<code>Connect</code>。这里的<code>Accessor</code>只是简单的把<code>Connect</code>的请求转发给了<code>TraceSource</code>。好几个类都有<code>Connect</code>，一不小心就晕头转向了，现在可以总结一下不同类的<code>Connect</code>到底做了什么，以及它们究竟时何时被调用的。</p>
<p>假设现在已经有一个ns3的类<code>MyObject</code>（fifth.cc)，也继承了Object，意味着它实现了<code>GetTypeId</code>，拥有了<code>Attribute</code>和<code>TraceSource</code>的能力。它有一个可以被trace的值<code>m_myInt</code>。这个值不是简单的类型，而是一个<code>TracedValue&lt;int32_t&gt; m_myInt;</code>。这样的话，只要对<code>m_myInt</code>进行赋值，Trace系统就可以工作了。给这个<code>m_myInt</code>赋值的话会调用什么？当然是<code>operator=</code>了。跳到<code>TracedValue</code>的对应实现看看：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">TracedValue <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">operator</span> <span style="color:#f92672">=</span> (<span style="color:#66d9ef">const</span> TracedValue <span style="color:#f92672">&amp;</span>o) {
  TRACED_VALUE_DEBUG (<span style="color:#e6db74">&#34;x=&#34;</span>);
  Set (o.m_v);
  <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
}

<span style="color:#75715e">// 关键就在`Set`里了，里面肯定有触发`Callback`的代码
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Set</span> (<span style="color:#66d9ef">const</span> T <span style="color:#f92672">&amp;</span>v) {
  <span style="color:#66d9ef">if</span> (m_v <span style="color:#f92672">!=</span> v)
    {
      m_cb (m_v, v);
      m_v <span style="color:#f92672">=</span> v;
    }
}
</code></pre></div><p>果然，有个<code>m_cb</code>，这就是我们之前提到的<code>TracedCallback</code>。每次给这个<code>m_myInt</code>赋值，就会调用<code>m_cb</code>通知这个值已经变化。可以看到，<code>TracedValue</code>本身提供了一个<code>Connect</code>的方法，这意味着我们可以直接用<code>m_myInt-&gt;Connect</code>来把自己的处理函数连接上去。但是实际中往往是通过<code>myObj-&gt;ConnectWithoutContext(&quot;myInt&quot;, MakeCallback(&amp;mycallback))</code>这样的方式。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">bool</span> 
ObjectBase<span style="color:#f92672">::</span>TraceConnectWithoutContext (std<span style="color:#f92672">::</span>string name, <span style="color:#66d9ef">const</span> CallbackBase <span style="color:#f92672">&amp;</span>cb)
{
  NS_LOG_FUNCTION (<span style="color:#66d9ef">this</span> <span style="color:#f92672">&lt;&lt;</span> name <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">&amp;</span>cb);
  TypeId tid <span style="color:#f92672">=</span> GetInstanceTypeId ();
  Ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">const</span> TraceSourceAccessor<span style="color:#f92672">&gt;</span> accessor <span style="color:#f92672">=</span> tid.LookupTraceSourceByName (name);
  <span style="color:#66d9ef">if</span> (accessor <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
    {
      <span style="color:#66d9ef">return</span> false;
    }
  <span style="color:#66d9ef">bool</span> ok <span style="color:#f92672">=</span> accessor<span style="color:#f92672">-&gt;</span>ConnectWithoutContext (<span style="color:#66d9ef">this</span>, cb);
  <span style="color:#66d9ef">return</span> ok;
}
</code></pre></div><p><code>Accessor</code>我们之前已经讲过了，是一个在<code>GetTypeId</code>里被调用并生成的一个类型，具体的<code>accessor-&gt;ConnectWithoutContext</code>在上面的<code>DoMakeTraceSourceAccessor</code>里有定义，还是通过了<code>SOURCE T::*a</code>这个类型得到了<code>TracedValue</code>在类中的位置，调用了这个类型的<code>ConnectWithoutContext</code>。</p>
<p>至于<code>TracedCallback</code>，理解起来就没什么难度了，在这个类型的<code>operator()</code>里，注册进来的<code>Callback</code>以此执行一遍即可。</p>
<p>所以在运行是整个trace的过程是这样的：</p>
<ol>
<li>m_myInt=1;会跑到<code>TracedValue</code>的<code>operator=</code></li>
<li><code>TracedValue::operator=</code>调用了与<code>m_myInt</code>相关联的<code>TracedCallback::operator()</code></li>
<li><code>TracedCallback::operator()</code>以此调用事先注册好的<code>Callback</code>。</li>
</ol>
<h1 id="总结">总结</h1>
<ol>
<li>IidManager是一个数据库，TypeId是数据库的key，Attribute和TraceSource是数据库的两张表。每在<code>GetTypeId</code>里<code>AddAttribute</code>或者<code>AddTraceSouce</code>一次就相当于给表里加一行记录，所有与<code>Attribute</code>、<code>TraceSource</code>相关的操作都会去表里找自己需要的信息。</li>
<li>大量运用了模板和宏来<em>生成</em>一些框架代码，比如Accessor。这也是代码难以理解之处的根本所在。熟悉一些模板的套路，比如CRTP（在object模型里用到）、PIMPL（callback里用到）；熟悉一些c++里的编程套路，比如在函数内部定义class（Accessor里用到），静态变量初始化（保证自定义Object可被注册时用到）；以及字面意义上的代码生成（宏，#与##），类型这个层次的代码生成（template，多个类型参数，traits），都是需要去细心体会的。</li>
</ol>
<h1 id="后记">后记</h1>
<p>C++真难。</p>
<p>这套代码看下来，也是让人惊叹C++真的是没有做不到，只有想不到。那些模板和宏生成代码的套路，基本上把能在编译期算的都在编译器搞定，能在初始化搞的全在初始化时完成，运行时跑得都是很难再简化的必要的逻辑。其实网络仿真程序也基本算一个&quot;well-defined&quot;的东西，有着明确的需求，又是开源项目，可以花心思把系统设计的如此巧妙。</p>
<p>希望自己以后能有机会能从头参与类似项目的开发，而不是在反复无常的业务逻辑上消磨时光。</p>
        </div>
        


<div class="post-info">
    
        <div class="post-date dt-published">2018-07-29</div>
    
    
    <a class="post-hidden-url u-url" href="https://ivkus.github.io/posts/ns3_typeid/">https://ivkus.github.io/posts/ns3_typeid/</a>
    <a href=https://ivkus.github.io/ class="p-name p-author post-hidden-author h-card" rel="me"></a>


    <div class="post-taxonomies">
        
            
                <ul class="post-tags">
                    
                        <li><a href="https://ivkus.github.io/tags/ns3">#ns3</a></li>
                    
                        <li><a href="https://ivkus.github.io/tags/cpp">#cpp</a></li>
                    
                </ul>
        
    </div>
</div>

    </article>

    

    

    


        </main>
        
            <footer class="common-footer">
    
    

    <div class="common-footer-bottom">
        
        <div class="copyright">
            <p>© 2022<br>
            Powered by <a target="_blank" rel="noopener noreferrer" href="https://gohugo.io/">Hugo</a>, theme <a target="_blank" rel="noopener noreferrer" href="https://github.com/mitrichius/hugo-theme-anubis">Anubis</a>.<br>
            
            </p>  
        </div> 

        


   
    </div>

    <p class="h-card vcard">

    <a href=https://ivkus.github.io/ class="p-name u-url url fn" rel="me"></a> 

    

    
</p> 
</footer>

        
    </div>
</body>
</html>
