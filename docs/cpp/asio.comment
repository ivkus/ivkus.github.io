
## socks5协议

socks5支持tcp/udp的代理，出于简化这里只讲述tcp。一般来说，我们会在一个跳板机上部署一个socks5代理程序，这个跳板机上是可以访问我们需要访问的网络（这个网络我们不能直接access）。

协议交互

在可以正式相互传输数据之前，客户端和代理之间会有4个包的交互，也就是2个请求与应答。第一个请求应答是协商认证的方式；这里选择最简单的不认证。第二个请求应答是客户端告诉代理想连哪个地址，应答则是告诉连接是否成功。

用asio的一点好处是，代码结构可以忠实反应协议的结构。我们选择用类来封装逻辑，所有的实现需要2个class，一个负责接受连接，叫listener；另一个就是连接本身的协议处理与消息收发，叫connection。listener接受连接后就生成新的connection，这是两个构件的基本关系。

### listener

我们先看listener，这个比较简单。

### connection

连接建立了需要先读消息才行，具体的读操作也是委托给了asio去完成的，委托之前需要把存数据的buffer和完成后的操作给到asio，这就是async_read的两个参数。这里就是调用者（也就是用户）的责任来确保这个buffer在回调被调用之前保持合法。所以我们把buffer搞成一个类变量，这样只要connection活着，这个buffer就是合法的。

注意buffer是有大小的。我们的回调只在两种情况下会被调用，一个是buffer被填充满了，另一个是这个连接出错了。这会反应在我们回调的2个入参上：errorcode和bytes transferred。然后依据读到的数据（存在了buffer里）或错误码进行下一步的逻辑。

读完了呢？读完了还要继续，所以在这个回调里继续发起读请求。只要这个链条接上了，就可以连续不断的处理上行请求了。

现在回头看一下，server端的每条协议逻辑都对应了一个方法，每个方法只focus一种协议的处理，很清晰。

这里刚开始比较绕的就是async_read与回调，写的时候需要提醒自己说哪个是发起请求（提出委托），哪个是回调（委托完成后通知自己）；这两个动作需要的材料（入参）都代表了什么。
